//
// Created by vijay on 01-04-2023.
//

#ifndef SFC_PARALLELIZATION_ALGORITHMS_H
#define SFC_PARALLELIZATION_ALGORITHMS_H

///all cluster size enumeration. clustersz = {size k = 1 to <= maxSFCLen, {enumerations vectors} }. Precalculated upto size=10.
static unordered_map<unsigned int, vector<vector<unsigned int>>> clusterSz = { {0 , {{}} },
    {1 , {{1}} }, // total 1
    {2 , {{1,1},{2}} },// total 2
    {3 , {{1,1,1},{2,1},{1,2},{3}}}, // total 4
    {4 , {{1,1,1,1},{2,1,1},{1,2,1},{3,1},{1,1,2},{2,2},{1,3},{4}}}, // total  8
    {5 , {{1,1,1,1,1},{2,1,1,1},{1,2,1,1},{3,1,1},{1,1,2,1},{2,2,1},{1,3,1},{4,1},{1,1,1,2},{2,1,2},{1,2,2},{3,2},{1,1,3},{2,3},{1,4},{5}}}, // total 16
    {6 , {{1,1,1,1,1,1},{2,1,1,1,1},{1,2,1,1,1},{3,1,1,1},{1,1,2,1,1},{2,2,1,1},{1,3,1,1},{4,1,1},{1,1,1,2,1},{2,1,2,1},{1,2,2,1},{3,2,1},
                {1,1,3,1},{2,3,1},{1,4,1},{5,1},{1,1,1,1,2},{2,1,1,2},{1,2,1,2},{3,1,2},{1,1,2,2},{2,2,2},{1,3,2},{4,2},{1,1,1,3},{2,1,3},{1,2,3},
                {3,3},{1,1,4},{2,4},{1,5},{6}}}, // total 32
    {7 , {{1,1,1,1,1,1,1},{2,1,1,1,1,1},{1,2,1,1,1,1},{3,1,1,1,1},{1,1,2,1,1,1},{2,2,1,1,1},{1,3,1,1,1},{4,1,1,1},{1,1,1,2,1,1},{2,1,2,1,1},
                {1,2,2,1,1},{3,2,1,1},{1,1,3,1,1},{2,3,1,1},{1,4,1,1},{5,1,1},{1,1,1,1,2,1},{2,1,1,2,1},{1,2,1,2,1},{3,1,2,1},{1,1,2,2,1},{2,2,2,1},
                {1,3,2,1},{4,2,1},{1,1,1,3,1},{2,1,3,1},{1,2,3,1},{3,3,1},{1,1,4,1},{2,4,1},{1,5,1},{6,1},{1,1,1,1,1,2},{2,1,1,1,2},{1,2,1,1,2},
                {3,1,1,2},{1,1,2,1,2},{2,2,1,2},{1,3,1,2},{4,1,2},{1,1,1,2,2},{2,1,2,2},{1,2,2,2},{3,2,2},{1,1,3,2},{2,3,2},{1,4,2},{5,2},{1,1,1,1,3},
                {2,1,1,3},{1,2,1,3},{3,1,3},{1,1,2,3},{2,2,3},{1,3,3},{4,3},{1,1,1,4},{2,1,4},{1,2,4},{3,4},{1,1,5},{2,5},{1,6},{7}}}, // total 64
    {8 , {{1,1,1,1,1,1,1,1},{2,1,1,1,1,1,1},{1,2,1,1,1,1,1},{3,1,1,1,1,1},{1,1,2,1,1,1,1},{2,2,1,1,1,1},{1,3,1,1,1,1},{4,1,1,1,1},{1,1,1,2,1,1,1},
                {2,1,2,1,1,1},{1,2,2,1,1,1},{3,2,1,1,1},{1,1,3,1,1,1},{2,3,1,1,1},{1,4,1,1,1},{5,1,1,1},{1,1,1,1,2,1,1},{2,1,1,2,1,1},{1,2,1,2,1,1},
                {3,1,2,1,1},{1,1,2,2,1,1},{2,2,2,1,1},{1,3,2,1,1},{4,2,1,1},{1,1,1,3,1,1},{2,1,3,1,1},{1,2,3,1,1},{3,3,1,1},{1,1,4,1,1},{2,4,1,1},
                {1,5,1,1},{6,1,1},{1,1,1,1,1,2,1},{2,1,1,1,2,1},{1,2,1,1,2,1},{3,1,1,2,1},{1,1,2,1,2,1},{2,2,1,2,1},{1,3,1,2,1},{4,1,2,1},{1,1,1,2,2,1},
                {2,1,2,2,1},{1,2,2,2,1},{3,2,2,1},{1,1,3,2,1},{2,3,2,1},{1,4,2,1},{5,2,1},{1,1,1,1,3,1},{2,1,1,3,1},{1,2,1,3,1},{3,1,3,1},{1,1,2,3,1},
                {2,2,3,1},{1,3,3,1},{4,3,1},{1,1,1,4,1},{2,1,4,1},{1,2,4,1},{3,4,1},{1,1,5,1},{2,5,1},{1,6,1},{7,1},{1,1,1,1,1,1,2},{2,1,1,1,1,2},
                {1,2,1,1,1,2},{3,1,1,1,2},{1,1,2,1,1,2},{2,2,1,1,2},{1,3,1,1,2},{4,1,1,2},{1,1,1,2,1,2},{2,1,2,1,2},{1,2,2,1,2},{3,2,1,2},{1,1,3,1,2},
                {2,3,1,2},{1,4,1,2},{5,1,2},{1,1,1,1,2,2},{2,1,1,2,2},{1,2,1,2,2},{3,1,2,2},{1,1,2,2,2},{2,2,2,2},{1,3,2,2},{4,2,2},{1,1,1,3,2},
                {2,1,3,2},{1,2,3,2},{3,3,2},{1,1,4,2},{2,4,2},{1,5,2},{6,2},{1,1,1,1,1,3},{2,1,1,1,3},{1,2,1,1,3},{3,1,1,3},{1,1,2,1,3},{2,2,1,3},
                {1,3,1,3},{4,1,3},{1,1,1,2,3},{2,1,2,3},{1,2,2,3},{3,2,3},{1,1,3,3},{2,3,3},{1,4,3},{5,3},{1,1,1,1,4},{2,1,1,4},{1,2,1,4},{3,1,4},
                {1,1,2,4},{2,2,4},{1,3,4},{4,4},{1,1,1,5},{2,1,5},{1,2,5},{3,5},{1,1,6},{2,6},{1,7},{8}}}, // total 128
    {9, {{1,1,1,1,1,1,1,1,1},{2,1,1,1,1,1,1,1},{1,2,1,1,1,1,1,1},{3,1,1,1,1,1,1},{1,1,2,1,1,1,1,1},{2,2,1,1,1,1,1},{1,3,1,1,1,1,1},{4,1,1,1,1,1},
         {1,1,1,2,1,1,1,1},{2,1,2,1,1,1,1},{1,2,2,1,1,1,1},{3,2,1,1,1,1},{1,1,3,1,1,1,1},{2,3,1,1,1,1},{1,4,1,1,1,1},{5,1,1,1,1},{1,1,1,1,2,1,1,1},
         {2,1,1,2,1,1,1},{1,2,1,2,1,1,1},{3,1,2,1,1,1},{1,1,2,2,1,1,1},{2,2,2,1,1,1},{1,3,2,1,1,1},{4,2,1,1,1},{1,1,1,3,1,1,1},{2,1,3,1,1,1},{1,2,3,1,1,1},
         {3,3,1,1,1},{1,1,4,1,1,1},{2,4,1,1,1},{1,5,1,1,1},{6,1,1,1},{1,1,1,1,1,2,1,1},{2,1,1,1,2,1,1},{1,2,1,1,2,1,1},{3,1,1,2,1,1},{1,1,2,1,2,1,1},{2,2,1,2,1,1},
         {1,3,1,2,1,1},{4,1,2,1,1},{1,1,1,2,2,1,1},{2,1,2,2,1,1},{1,2,2,2,1,1},{3,2,2,1,1},{1,1,3,2,1,1},{2,3,2,1,1},{1,4,2,1,1},{5,2,1,1},{1,1,1,1,3,1,1},
         {2,1,1,3,1,1},{1,2,1,3,1,1},{3,1,3,1,1},{1,1,2,3,1,1},{2,2,3,1,1},{1,3,3,1,1},{4,3,1,1},{1,1,1,4,1,1},{2,1,4,1,1},{1,2,4,1,1},{3,4,1,1},{1,1,5,1,1},
         {2,5,1,1},{1,6,1,1},{7,1,1},{1,1,1,1,1,1,2,1},{2,1,1,1,1,2,1},{1,2,1,1,1,2,1},{3,1,1,1,2,1},{1,1,2,1,1,2,1},{2,2,1,1,2,1},{1,3,1,1,2,1},{4,1,1,2,1},
         {1,1,1,2,1,2,1},{2,1,2,1,2,1},{1,2,2,1,2,1},{3,2,1,2,1},{1,1,3,1,2,1},{2,3,1,2,1},{1,4,1,2,1},{5,1,2,1},{1,1,1,1,2,2,1},{2,1,1,2,2,1},{1,2,1,2,2,1},
         {3,1,2,2,1},{1,1,2,2,2,1},{2,2,2,2,1},{1,3,2,2,1},{4,2,2,1},{1,1,1,3,2,1},{2,1,3,2,1},{1,2,3,2,1},{3,3,2,1},{1,1,4,2,1},{2,4,2,1},{1,5,2,1},{6,2,1},
         {1,1,1,1,1,3,1},{2,1,1,1,3,1},{1,2,1,1,3,1},{3,1,1,3,1},{1,1,2,1,3,1},{2,2,1,3,1},{1,3,1,3,1},{4,1,3,1},{1,1,1,2,3,1},{2,1,2,3,1},{1,2,2,3,1},{3,2,3,1},
         {1,1,3,3,1},{2,3,3,1},{1,4,3,1},{5,3,1},{1,1,1,1,4,1},{2,1,1,4,1},{1,2,1,4,1},{3,1,4,1},{1,1,2,4,1},{2,2,4,1},{1,3,4,1},{4,4,1},{1,1,1,5,1},{2,1,5,1},{1,2,5,1},
         {3,5,1},{1,1,6,1},{2,6,1},{1,7,1},{8,1},{1,1,1,1,1,1,1,2},{2,1,1,1,1,1,2},{1,2,1,1,1,1,2},{3,1,1,1,1,2},{1,1,2,1,1,1,2},{2,2,1,1,1,2},{1,3,1,1,1,2},
         {4,1,1,1,2},{1,1,1,2,1,1,2},{2,1,2,1,1,2},{1,2,2,1,1,2},{3,2,1,1,2},{1,1,3,1,1,2},{2,3,1,1,2},{1,4,1,1,2},{5,1,1,2},{1,1,1,1,2,1,2},{2,1,1,2,1,2},{1,2,1,2,1,2},
         {3,1,2,1,2},{1,1,2,2,1,2},{2,2,2,1,2},{1,3,2,1,2},{4,2,1,2},{1,1,1,3,1,2},{2,1,3,1,2},{1,2,3,1,2},{3,3,1,2},{1,1,4,1,2},{2,4,1,2},{1,5,1,2},{6,1,2},{1,1,1,1,1,2,2},
         {2,1,1,1,2,2},{1,2,1,1,2,2},{3,1,1,2,2},{1,1,2,1,2,2},{2,2,1,2,2},{1,3,1,2,2},{4,1,2,2},{1,1,1,2,2,2},{2,1,2,2,2},{1,2,2,2,2},{3,2,2,2},{1,1,3,2,2},{2,3,2,2},{1,4,2,2},
         {5,2,2},{1,1,1,1,3,2},{2,1,1,3,2},{1,2,1,3,2},{3,1,3,2},{1,1,2,3,2},{2,2,3,2},{1,3,3,2},{4,3,2},{1,1,1,4,2},{2,1,4,2},{1,2,4,2},{3,4,2},{1,1,5,2},{2,5,2},{1,6,2},{7,2},
         {1,1,1,1,1,1,3},{2,1,1,1,1,3},{1,2,1,1,1,3},{3,1,1,1,3},{1,1,2,1,1,3},{2,2,1,1,3},{1,3,1,1,3},{4,1,1,3},{1,1,1,2,1,3},{2,1,2,1,3},{1,2,2,1,3},{3,2,1,3},{1,1,3,1,3},
         {2,3,1,3},{1,4,1,3},{5,1,3},{1,1,1,1,2,3},{2,1,1,2,3},{1,2,1,2,3},{3,1,2,3},{1,1,2,2,3},{2,2,2,3},{1,3,2,3},{4,2,3},{1,1,1,3,3},{2,1,3,3},{1,2,3,3},{3,3,3},{1,1,4,3},
         {2,4,3},{1,5,3},{6,3},{1,1,1,1,1,4},{2,1,1,1,4},{1,2,1,1,4},{3,1,1,4},{1,1,2,1,4},{2,2,1,4},{1,3,1,4},{4,1,4},{1,1,1,2,4},{2,1,2,4},{1,2,2,4},{3,2,4},{1,1,3,4},{2,3,4},
         {1,4,4},{5,4},{1,1,1,1,5},{2,1,1,5},{1,2,1,5},{3,1,5},{1,1,2,5},{2,2,5},{1,3,5},{4,5},{1,1,1,6},{2,1,6},{1,2,6},{3,6},{1,1,7},{2,7},{1,8},{9}} }, //total 256
        {10, {{1,1,1,1,1,1,1,1,1,1},{2,1,1,1,1,1,1,1,1},{1,2,1,1,1,1,1,1,1},{3,1,1,1,1,1,1,1},{1,1,2,1,1,1,1,1,1},{2,2,1,1,1,1,1,1},{1,3,1,1,1,1,1,1},{4,1,1,1,1,1,1},{1,1,1,2,1,1,1,1,1},
              {2,1,2,1,1,1,1,1},{1,2,2,1,1,1,1,1},{3,2,1,1,1,1,1},{1,1,3,1,1,1,1,1},{2,3,1,1,1,1,1},{1,4,1,1,1,1,1},{5,1,1,1,1,1},{1,1,1,1,2,1,1,1,1},{2,1,1,2,1,1,1,1},{1,2,1,2,1,1,1,1},
              {3,1,2,1,1,1,1},{1,1,2,2,1,1,1,1},{2,2,2,1,1,1,1},{1,3,2,1,1,1,1},{4,2,1,1,1,1},{1,1,1,3,1,1,1,1},{2,1,3,1,1,1,1},{1,2,3,1,1,1,1},{3,3,1,1,1,1},{1,1,4,1,1,1,1},{2,4,1,1,1,1},
              {1,5,1,1,1,1},{6,1,1,1,1},{1,1,1,1,1,2,1,1,1},{2,1,1,1,2,1,1,1},{1,2,1,1,2,1,1,1},{3,1,1,2,1,1,1},{1,1,2,1,2,1,1,1},{2,2,1,2,1,1,1},{1,3,1,2,1,1,1},{4,1,2,1,1,1},{1,1,1,2,2,1,1,1},
              {2,1,2,2,1,1,1},{1,2,2,2,1,1,1},{3,2,2,1,1,1},{1,1,3,2,1,1,1},{2,3,2,1,1,1},{1,4,2,1,1,1},{5,2,1,1,1},{1,1,1,1,3,1,1,1},{2,1,1,3,1,1,1},{1,2,1,3,1,1,1},{3,1,3,1,1,1},{1,1,2,3,1,1,1},
              {2,2,3,1,1,1},{1,3,3,1,1,1},{4,3,1,1,1},{1,1,1,4,1,1,1},{2,1,4,1,1,1},{1,2,4,1,1,1},{3,4,1,1,1},{1,1,5,1,1,1},{2,5,1,1,1},{1,6,1,1,1},{7,1,1,1},{1,1,1,1,1,1,2,1,1},{2,1,1,1,1,2,1,1},
              {1,2,1,1,1,2,1,1},{3,1,1,1,2,1,1},{1,1,2,1,1,2,1,1},{2,2,1,1,2,1,1},{1,3,1,1,2,1,1},{4,1,1,2,1,1},{1,1,1,2,1,2,1,1},{2,1,2,1,2,1,1},{1,2,2,1,2,1,1},{3,2,1,2,1,1},{1,1,3,1,2,1,1},
              {2,3,1,2,1,1},{1,4,1,2,1,1},{5,1,2,1,1},{1,1,1,1,2,2,1,1},{2,1,1,2,2,1,1},{1,2,1,2,2,1,1},{3,1,2,2,1,1},{1,1,2,2,2,1,1},{2,2,2,2,1,1},{1,3,2,2,1,1},{4,2,2,1,1},{1,1,1,3,2,1,1},
              {2,1,3,2,1,1},{1,2,3,2,1,1},{3,3,2,1,1},{1,1,4,2,1,1},{2,4,2,1,1},{1,5,2,1,1},{6,2,1,1},{1,1,1,1,1,3,1,1},{2,1,1,1,3,1,1},{1,2,1,1,3,1,1},{3,1,1,3,1,1},{1,1,2,1,3,1,1},{2,2,1,3,1,1},
              {1,3,1,3,1,1},{4,1,3,1,1},{1,1,1,2,3,1,1},{2,1,2,3,1,1},{1,2,2,3,1,1},{3,2,3,1,1},{1,1,3,3,1,1},{2,3,3,1,1},{1,4,3,1,1},{5,3,1,1},{1,1,1,1,4,1,1},{2,1,1,4,1,1},{1,2,1,4,1,1},{3,1,4,1,1},
              {1,1,2,4,1,1},{2,2,4,1,1},{1,3,4,1,1},{4,4,1,1},{1,1,1,5,1,1},{2,1,5,1,1},{1,2,5,1,1},{3,5,1,1},{1,1,6,1,1},{2,6,1,1},{1,7,1,1},{8,1,1},{1,1,1,1,1,1,1,2,1},{2,1,1,1,1,1,2,1},
              {1,2,1,1,1,1,2,1},{3,1,1,1,1,2,1},{1,1,2,1,1,1,2,1},{2,2,1,1,1,2,1},{1,3,1,1,1,2,1},{4,1,1,1,2,1},{1,1,1,2,1,1,2,1},{2,1,2,1,1,2,1},{1,2,2,1,1,2,1},{3,2,1,1,2,1},{1,1,3,1,1,2,1},
              {2,3,1,1,2,1},{1,4,1,1,2,1},{5,1,1,2,1},{1,1,1,1,2,1,2,1},{2,1,1,2,1,2,1},{1,2,1,2,1,2,1},{3,1,2,1,2,1},{1,1,2,2,1,2,1},{2,2,2,1,2,1},{1,3,2,1,2,1},{4,2,1,2,1},{1,1,1,3,1,2,1},
              {2,1,3,1,2,1},{1,2,3,1,2,1},{3,3,1,2,1},{1,1,4,1,2,1},{2,4,1,2,1},{1,5,1,2,1},{6,1,2,1},{1,1,1,1,1,2,2,1},{2,1,1,1,2,2,1},{1,2,1,1,2,2,1},{3,1,1,2,2,1},{1,1,2,1,2,2,1},{2,2,1,2,2,1},
              {1,3,1,2,2,1},{4,1,2,2,1},{1,1,1,2,2,2,1},{2,1,2,2,2,1},{1,2,2,2,2,1},{3,2,2,2,1},{1,1,3,2,2,1},{2,3,2,2,1},{1,4,2,2,1},{5,2,2,1},{1,1,1,1,3,2,1},{2,1,1,3,2,1},{1,2,1,3,2,1},
              {3,1,3,2,1},{1,1,2,3,2,1},{2,2,3,2,1},{1,3,3,2,1},{4,3,2,1},{1,1,1,4,2,1},{2,1,4,2,1},{1,2,4,2,1},{3,4,2,1},{1,1,5,2,1},{2,5,2,1},{1,6,2,1},{7,2,1},{1,1,1,1,1,1,3,1},{2,1,1,1,1,3,1},
              {1,2,1,1,1,3,1},{3,1,1,1,3,1},{1,1,2,1,1,3,1},{2,2,1,1,3,1},{1,3,1,1,3,1},{4,1,1,3,1},{1,1,1,2,1,3,1},{2,1,2,1,3,1},{1,2,2,1,3,1},{3,2,1,3,1},{1,1,3,1,3,1},{2,3,1,3,1},{1,4,1,3,1},
              {5,1,3,1},{1,1,1,1,2,3,1},{2,1,1,2,3,1},{1,2,1,2,3,1},{3,1,2,3,1},{1,1,2,2,3,1},{2,2,2,3,1},{1,3,2,3,1},{4,2,3,1},{1,1,1,3,3,1},{2,1,3,3,1},{1,2,3,3,1},{3,3,3,1},{1,1,4,3,1},{2,4,3,1},
              {1,5,3,1},{6,3,1},{1,1,1,1,1,4,1},{2,1,1,1,4,1},{1,2,1,1,4,1},{3,1,1,4,1},{1,1,2,1,4,1},{2,2,1,4,1},{1,3,1,4,1},{4,1,4,1},{1,1,1,2,4,1},{2,1,2,4,1},{1,2,2,4,1},{3,2,4,1},
              {1,1,3,4,1},{2,3,4,1},{1,4,4,1},{5,4,1},{1,1,1,1,5,1},{2,1,1,5,1},{1,2,1,5,1},{3,1,5,1},{1,1,2,5,1},{2,2,5,1},{1,3,5,1},{4,5,1},{1,1,1,6,1},{2,1,6,1},{1,2,6,1},{3,6,1},{1,1,7,1},
              {2,7,1},{1,8,1},{9,1},{1,1,1,1,1,1,1,1,2},{2,1,1,1,1,1,1,2},{1,2,1,1,1,1,1,2},{3,1,1,1,1,1,2},{1,1,2,1,1,1,1,2},{2,2,1,1,1,1,2},{1,3,1,1,1,1,2},{4,1,1,1,1,2},{1,1,1,2,1,1,1,2},
              {2,1,2,1,1,1,2},{1,2,2,1,1,1,2},{3,2,1,1,1,2},{1,1,3,1,1,1,2},{2,3,1,1,1,2},{1,4,1,1,1,2},{5,1,1,1,2},{1,1,1,1,2,1,1,2},{2,1,1,2,1,1,2},{1,2,1,2,1,1,2},{3,1,2,1,1,2},{1,1,2,2,1,1,2},
              {2,2,2,1,1,2},{1,3,2,1,1,2},{4,2,1,1,2},{1,1,1,3,1,1,2},{2,1,3,1,1,2},{1,2,3,1,1,2},{3,3,1,1,2},{1,1,4,1,1,2},{2,4,1,1,2},{1,5,1,1,2},{6,1,1,2},{1,1,1,1,1,2,1,2},{2,1,1,1,2,1,2},
              {1,2,1,1,2,1,2},{3,1,1,2,1,2},{1,1,2,1,2,1,2},{2,2,1,2,1,2},{1,3,1,2,1,2},{4,1,2,1,2},{1,1,1,2,2,1,2},{2,1,2,2,1,2},{1,2,2,2,1,2},{3,2,2,1,2},{1,1,3,2,1,2},{2,3,2,1,2},{1,4,2,1,2},
              {5,2,1,2},{1,1,1,1,3,1,2},{2,1,1,3,1,2},{1,2,1,3,1,2},{3,1,3,1,2},{1,1,2,3,1,2},{2,2,3,1,2},{1,3,3,1,2},{4,3,1,2},{1,1,1,4,1,2},{2,1,4,1,2},{1,2,4,1,2},{3,4,1,2},{1,1,5,1,2},{2,5,1,2},
              {1,6,1,2},{7,1,2},{1,1,1,1,1,1,2,2},{2,1,1,1,1,2,2},{1,2,1,1,1,2,2},{3,1,1,1,2,2},{1,1,2,1,1,2,2},{2,2,1,1,2,2},{1,3,1,1,2,2},{4,1,1,2,2},{1,1,1,2,1,2,2},{2,1,2,1,2,2},{1,2,2,1,2,2},
              {3,2,1,2,2},{1,1,3,1,2,2},{2,3,1,2,2},{1,4,1,2,2},{5,1,2,2},{1,1,1,1,2,2,2},{2,1,1,2,2,2},{1,2,1,2,2,2},{3,1,2,2,2},{1,1,2,2,2,2},{2,2,2,2,2},{1,3,2,2,2},{4,2,2,2},{1,1,1,3,2,2},
              {2,1,3,2,2},{1,2,3,2,2},{3,3,2,2},{1,1,4,2,2},{2,4,2,2},{1,5,2,2},{6,2,2},{1,1,1,1,1,3,2},{2,1,1,1,3,2},{1,2,1,1,3,2},{3,1,1,3,2},{1,1,2,1,3,2},{2,2,1,3,2},{1,3,1,3,2},{4,1,3,2},
              {1,1,1,2,3,2},{2,1,2,3,2},{1,2,2,3,2},{3,2,3,2},{1,1,3,3,2},{2,3,3,2},{1,4,3,2},{5,3,2},{1,1,1,1,4,2},{2,1,1,4,2},{1,2,1,4,2},{3,1,4,2},{1,1,2,4,2},{2,2,4,2},{1,3,4,2},{4,4,2},
              {1,1,1,5,2},{2,1,5,2},{1,2,5,2},{3,5,2},{1,1,6,2},{2,6,2},{1,7,2},{8,2},{1,1,1,1,1,1,1,3},{2,1,1,1,1,1,3},{1,2,1,1,1,1,3},{3,1,1,1,1,3},{1,1,2,1,1,1,3},{2,2,1,1,1,3},{1,3,1,1,1,3},
              {4,1,1,1,3},{1,1,1,2,1,1,3},{2,1,2,1,1,3},{1,2,2,1,1,3},{3,2,1,1,3},{1,1,3,1,1,3},{2,3,1,1,3},{1,4,1,1,3},{5,1,1,3},{1,1,1,1,2,1,3},{2,1,1,2,1,3},{1,2,1,2,1,3},{3,1,2,1,3},
              {1,1,2,2,1,3},{2,2,2,1,3},{1,3,2,1,3},{4,2,1,3},{1,1,1,3,1,3},{2,1,3,1,3},{1,2,3,1,3},{3,3,1,3},{1,1,4,1,3},{2,4,1,3},{1,5,1,3},{6,1,3},{1,1,1,1,1,2,3},{2,1,1,1,2,3},{1,2,1,1,2,3},
              {3,1,1,2,3},{1,1,2,1,2,3},{2,2,1,2,3},{1,3,1,2,3},{4,1,2,3},{1,1,1,2,2,3},{2,1,2,2,3},{1,2,2,2,3},{3,2,2,3},{1,1,3,2,3},{2,3,2,3},{1,4,2,3},{5,2,3},{1,1,1,1,3,3},{2,1,1,3,3},
              {1,2,1,3,3},{3,1,3,3},{1,1,2,3,3},{2,2,3,3},{1,3,3,3},{4,3,3},{1,1,1,4,3},{2,1,4,3},{1,2,4,3},{3,4,3},{1,1,5,3},{2,5,3},{1,6,3},{7,3},{1,1,1,1,1,1,4},{2,1,1,1,1,4},{1,2,1,1,1,4},
              {3,1,1,1,4},{1,1,2,1,1,4},{2,2,1,1,4},{1,3,1,1,4},{4,1,1,4},{1,1,1,2,1,4},{2,1,2,1,4},{1,2,2,1,4},{3,2,1,4},{1,1,3,1,4},{2,3,1,4},{1,4,1,4},{5,1,4},{1,1,1,1,2,4},{2,1,1,2,4},
              {1,2,1,2,4},{3,1,2,4},{1,1,2,2,4},{2,2,2,4},{1,3,2,4},{4,2,4},{1,1,1,3,4},{2,1,3,4},{1,2,3,4},{3,3,4},{1,1,4,4},{2,4,4},{1,5,4},{6,4},{1,1,1,1,1,5},{2,1,1,1,5},{1,2,1,1,5},
              {3,1,1,5},{1,1,2,1,5},{2,2,1,5},{1,3,1,5},{4,1,5},{1,1,1,2,5},{2,1,2,5},{1,2,2,5},{3,2,5},{1,1,3,5},{2,3,5},{1,4,5},{5,5},{1,1,1,1,6},{2,1,1,6},{1,2,1,6},{3,1,6},{1,1,2,6},{2,2,6},
              {1,3,6},{4,6},{1,1,1,7},{2,1,7},{1,2,7},{3,7},{1,1,8},{2,8},{1,9},{10}}} //total 512
};

/// all combination vectors (nCk)  for given n and k, {n=size 1<=n<=maxSFClen, k= 1<=k<=n{{k=1, 2d vec}, {k=2, 2d vec}}}. Precalculated upto n=10.
static unordered_map<unsigned int,unordered_map<unsigned int,vector<vector<unsigned int>>>> nCk ={
        {0, {   {0, {{1}}  } } }, // (0,0) = 1 way, index zero based
        {1, {   {1, {{1}}  } } },
        {2, {
                {1,     {{1},{2}}   },
                {2,     {{1,2}}    }
            }
        },
        {3, {
                {1, { {1},{2},{3} } },
                {2, { {1,2},{1,3},{2,3}} },
                {3, { {1,2,3}} }
            }
        },
        {4, {
                {1, {{1}, {2}, {3}, {4}} },
                {2, {{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}} },
                {3, {{1,2,3},{1,2,4},{1,3,4}, {2,3,4}}},
                {4, {{1,2,3,4}}}
            }
        },
        {5, {
                    {1, {{1},{2},{3},{4},{5}} },
                    {2, {{1,2},{1,3},{1,4},{1,5},{2,3},{2,4},{2,5},{3,4},{3,5},{4,5}} },
                    {3, {{1,2,3},{1,2,4},{1,2,5},{1,3,4},{1,3,5},{1,4,5},{2,3,4},{2,3,5},{2,4,5},{3,4,5}}},
                    {4, {{1,2,3,4},{1,2,3,5},{1,2,4,5},{1,3,4,5},{2,3,4,5}}},
                    {5, {{1, 2, 3, 4, 5}}}
            }
        },
        {6, {
                    {1, { {1},{2},{3},{4},{5},{6}}},
                    {2, { {1,2},{1,3},{1,4},{1,5},{1,6},{2,3},{2,4},{2,5},{2,6},{3,4},{3,5},{3,6},{4,5},{4,6},{5,6}}},
                    {3, { {1,2,3},{1,2,4},{1,2,5},{1,2,6},{1,3,4},{1,3,5},{1,3,6},{1,4,5},{1,4,6},{1,5,6},{2,3,4},{2,3,5},{2,3,6},{2,4,5},{2,4,6},{2,5,6},{3,4,5},{3,4,6},{3,5,6},{4,5,6}}},
                    {4, { {1,2,3,4},{1,2,3,5},{1,2,3,6},{1,2,4,5},{1,2,4,6},{1,2,5,6},{1,3,4,5},{1,3,4,6},{1,3,5,6},{1,4,5,6},{2,3,4,5},{2,3,4,6},{2,3,5,6},{2,4,5,6},{3,4,5,6}}},
                    {5, { {1,2,3,4,5},{1,2,3,4,6},{1,2,3,5,6},{1,2,4,5,6},{1,3,4,5,6},{2,3,4,5,6}}},
                    {6, { {1,2,3,4,5,6}}}
            }
        },
        {7, {
                    {1, { {1},{2},{3},{4},{5},{6},{7}}},
                    {2, { {1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{2,3},{2,4},{2,5},{2,6},{2,7},{3,4},{3,5},{3,6},{3,7},{4,5},{4,6},{4,7},{5,6},{5,7},{6,7}}},
                    {3, { {1,2,3},{1,2,4},{1,2,5},{1,2,6},{1,2,7},{1,3,4},{1,3,5},{1,3,6},{1,3,7},{1,4,5},{1,4,6},{1,4,7},{1,5,6},{1,5,7},{1,6,7},{2,3,4},{2,3,5},{2,3,6},{2,3,7},
                                {2,4,5},{2,4,6},{2,4,7},{2,5,6},{2,5,7},{2,6,7},{3,4,5},{3,4,6},{3,4,7},{3,5,6},{3,5,7},{3,6,7},{4,5,6},{4,5,7},{4,6,7},{5,6,7}}},
                    {4, { {1,2,3,4},{1,2,3,5},{1,2,3,6},{1,2,3,7},{1,2,4,5},{1,2,4,6},{1,2,4,7},{1,2,5,6},{1,2,5,7},{1,2,6,7},{1,3,4,5},{1,3,4,6},{1,3,4,7},{1,3,5,6},{1,3,5,7},
                                {1,3,6,7},{1,4,5,6},{1,4,5,7},{1,4,6,7},{1,5,6,7},{2,3,4,5},{2,3,4,6},{2,3,4,7},{2,3,5,6},{2,3,5,7},{2,3,6,7},{2,4,5,6},{2,4,5,7},{2,4,6,7},{2,5,6,7},
                                {3,4,5,6},{3,4,5,7},{3,4,6,7},{3,5,6,7},{4,5,6,7}}},
                    {5, { {1,2,3,4,5},{1,2,3,4,6},{1,2,3,4,7},{1,2,3,5,6},{1,2,3,5,7},{1,2,3,6,7},{1,2,4,5,6},{1,2,4,5,7},{1,2,4,6,7},{1,2,5,6,7},{1,3,4,5,6},{1,3,4,5,7},{1,3,4,6,7},
                                {1,3,5,6,7},{1,4,5,6,7},{2,3,4,5,6},{2,3,4,5,7},{2,3,4,6,7},{2,3,5,6,7},{2,4,5,6,7},{3,4,5,6,7}}},
                    {6, { {1,2,3,4,5,6},{1,2,3,4,5,7},{1,2,3,4,6,7},{1,2,3,5,6,7},{1,2,4,5,6,7},{1,3,4,5,6,7},{2,3,4,5,6,7}}},
                    {7, { {1,2,3,4,5,6,7}}}
            }
        },
        {8, {
                    {1, { {1},{2},{3},{4},{5},{6},{7},{8}}},
                    {2, { {1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{3,4},{3,5},{3,6},{3,7},{3,8},{4,5},{4,6},{4,7},{4,8},{5,6},{5,7},{5,8},{6,7},{6,8},{7,8}}},
                    {3, { {1,2,3},{1,2,4},{1,2,5},{1,2,6},{1,2,7},{1,2,8},{1,3,4},{1,3,5},{1,3,6},{1,3,7},{1,3,8},{1,4,5},{1,4,6},{1,4,7},{1,4,8},{1,5,6},{1,5,7},{1,5,8},{1,6,7},{1,6,8},
                          {1,7,8},{2,3,4},{2,3,5},{2,3,6},{2,3,7},{2,3,8},{2,4,5},{2,4,6},{2,4,7},{2,4,8},{2,5,6},{2,5,7},{2,5,8},{2,6,7},{2,6,8},{2,7,8},{3,4,5},{3,4,6},{3,4,7},{3,4,8},{3,5,6},
                          {3,5,7},{3,5,8},{3,6,7},{3,6,8},{3,7,8},{4,5,6},{4,5,7},{4,5,8},{4,6,7},{4,6,8},{4,7,8},{5,6,7},{5,6,8},{5,7,8},{6,7,8}}},
                    {4, { {1,2,3,4},{1,2,3,5},{1,2,3,6},{1,2,3,7},{1,2,3,8},{1,2,4,5},{1,2,4,6},{1,2,4,7},{1,2,4,8},{1,2,5,6},{1,2,5,7},{1,2,5,8},{1,2,6,7},{1,2,6,8},{1,2,7,8},{1,3,4,5},
                          {1,3,4,6},{1,3,4,7},{1,3,4,8},{1,3,5,6},{1,3,5,7},{1,3,5,8},{1,3,6,7},{1,3,6,8},{1,3,7,8},{1,4,5,6},{1,4,5,7},{1,4,5,8},{1,4,6,7},{1,4,6,8},{1,4,7,8},{1,5,6,7},{1,5,6,8},
                          {1,5,7,8},{1,6,7,8},{2,3,4,5},{2,3,4,6},{2,3,4,7},{2,3,4,8},{2,3,5,6},{2,3,5,7},{2,3,5,8},{2,3,6,7},{2,3,6,8},{2,3,7,8},{2,4,5,6},{2,4,5,7},{2,4,5,8},{2,4,6,7},{2,4,6,8},
                          {2,4,7,8},{2,5,6,7},{2,5,6,8},{2,5,7,8},{2,6,7,8},{3,4,5,6},{3,4,5,7},{3,4,5,8},{3,4,6,7},{3,4,6,8},{3,4,7,8},{3,5,6,7},{3,5,6,8},{3,5,7,8},{3,6,7,8},{4,5,6,7},{4,5,6,8},
                          {4,5,7,8},{4,6,7,8},{5,6,7,8}}},
                    {5, { {1,2,3,4,5},{1,2,3,4,6},{1,2,3,4,7},{1,2,3,4,8},{1,2,3,5,6},{1,2,3,5,7},{1,2,3,5,8},{1,2,3,6,7},{1,2,3,6,8},{1,2,3,7,8},{1,2,4,5,6},{1,2,4,5,7},{1,2,4,5,8},
                          {1,2,4,6,7},{1,2,4,6,8},{1,2,4,7,8},{1,2,5,6,7},{1,2,5,6,8},{1,2,5,7,8},{1,2,6,7,8},{1,3,4,5,6},{1,3,4,5,7},{1,3,4,5,8},{1,3,4,6,7},{1,3,4,6,8},{1,3,4,7,8},{1,3,5,6,7},
                          {1,3,5,6,8},{1,3,5,7,8},{1,3,6,7,8},{1,4,5,6,7},{1,4,5,6,8},{1,4,5,7,8},{1,4,6,7,8},{1,5,6,7,8},{2,3,4,5,6},{2,3,4,5,7},{2,3,4,5,8},{2,3,4,6,7},{2,3,4,6,8},{2,3,4,7,8},
                          {2,3,5,6,7},{2,3,5,6,8},{2,3,5,7,8},{2,3,6,7,8},{2,4,5,6,7},{2,4,5,6,8},{2,4,5,7,8},{2,4,6,7,8},{2,5,6,7,8},{3,4,5,6,7},{3,4,5,6,8},{3,4,5,7,8},{3,4,6,7,8},{3,5,6,7,8},{4,5,6,7,8}}},
                    {6, { {1,2,3,4,5,6},{1,2,3,4,5,7},{1,2,3,4,5,8},{1,2,3,4,6,7},{1,2,3,4,6,8},{1,2,3,4,7,8},{1,2,3,5,6,7},{1,2,3,5,6,8},{1,2,3,5,7,8},{1,2,3,6,7,8},{1,2,4,5,6,7},{1,2,4,5,6,8},
                          {1,2,4,5,7,8},{1,2,4,6,7,8},{1,2,5,6,7,8},{1,3,4,5,6,7},{1,3,4,5,6,8},{1,3,4,5,7,8},{1,3,4,6,7,8},{1,3,5,6,7,8},{1,4,5,6,7,8},{2,3,4,5,6,7},{2,3,4,5,6,8},{2,3,4,5,7,8},
                          {2,3,4,6,7,8},{2,3,5,6,7,8},{2,4,5,6,7,8},{3,4,5,6,7,8}}},
                    {7, { {1,2,3,4,5,6,7},{1,2,3,4,5,6,8},{1,2,3,4,5,7,8},{1,2,3,4,6,7,8},{1,2,3,5,6,7,8},{1,2,4,5,6,7,8},{1,3,4,5,6,7,8},{2,3,4,5,6,7,8}}},
                    {8, { {1,2,3,4,5,6,7,8}}}
            }
        },
        {9, {
                    {1, { {1},{2},{3},{4},{5},{6},{7},{8},{9}}},
                    {2, { {1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{1,9},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{2,9},{3,4},{3,5},{3,6},{3,7},{3,8},{3,9},{4,5},{4,6},{4,7},{4,8},{4,9},{5,6},
                          {5,7},{5,8},{5,9},{6,7},{6,8},{6,9},{7,8},{7,9},{8,9}}},
                    {3, { {1,2,3},{1,2,4},{1,2,5},{1,2,6},{1,2,7},{1,2,8},{1,2,9},{1,3,4},{1,3,5},{1,3,6},{1,3,7},{1,3,8},{1,3,9},{1,4,5},{1,4,6},{1,4,7},{1,4,8},{1,4,9},{1,5,6},{1,5,7},
                          {1,5,8},{1,5,9},{1,6,7},{1,6,8},{1,6,9},{1,7,8},{1,7,9},{1,8,9},{2,3,4},{2,3,5},{2,3,6},{2,3,7},{2,3,8},{2,3,9},{2,4,5},{2,4,6},{2,4,7},{2,4,8},{2,4,9},{2,5,6},{2,5,7},
                          {2,5,8},{2,5,9},{2,6,7},{2,6,8},{2,6,9},{2,7,8},{2,7,9},{2,8,9},{3,4,5},{3,4,6},{3,4,7},{3,4,8},{3,4,9},{3,5,6},{3,5,7},{3,5,8},{3,5,9},{3,6,7},{3,6,8},{3,6,9},{3,7,8},
                          {3,7,9},{3,8,9},{4,5,6},{4,5,7},{4,5,8},{4,5,9},{4,6,7},{4,6,8},{4,6,9},{4,7,8},{4,7,9},{4,8,9},{5,6,7},{5,6,8},{5,6,9},{5,7,8},{5,7,9},{5,8,9},{6,7,8},{6,7,9},{6,8,9},{7,8,9}}},
                    {4, { {1,2,3,4},{1,2,3,5},{1,2,3,6},{1,2,3,7},{1,2,3,8},{1,2,3,9},{1,2,4,5},{1,2,4,6},{1,2,4,7},{1,2,4,8},{1,2,4,9},{1,2,5,6},{1,2,5,7},{1,2,5,8},{1,2,5,9},{1,2,6,7},
                          {1,2,6,8},{1,2,6,9},{1,2,7,8},{1,2,7,9},{1,2,8,9},{1,3,4,5},{1,3,4,6},{1,3,4,7},{1,3,4,8},{1,3,4,9},{1,3,5,6},{1,3,5,7},{1,3,5,8},{1,3,5,9},{1,3,6,7},{1,3,6,8},{1,3,6,9},
                          {1,3,7,8},{1,3,7,9},{1,3,8,9},{1,4,5,6},{1,4,5,7},{1,4,5,8},{1,4,5,9},{1,4,6,7},{1,4,6,8},{1,4,6,9},{1,4,7,8},{1,4,7,9},{1,4,8,9},{1,5,6,7},{1,5,6,8},{1,5,6,9},{1,5,7,8},
                          {1,5,7,9},{1,5,8,9},{1,6,7,8},{1,6,7,9},{1,6,8,9},{1,7,8,9},{2,3,4,5},{2,3,4,6},{2,3,4,7},{2,3,4,8},{2,3,4,9},{2,3,5,6},{2,3,5,7},{2,3,5,8},{2,3,5,9},{2,3,6,7},{2,3,6,8},
                          {2,3,6,9},{2,3,7,8},{2,3,7,9},{2,3,8,9},{2,4,5,6},{2,4,5,7},{2,4,5,8},{2,4,5,9},{2,4,6,7},{2,4,6,8},{2,4,6,9},{2,4,7,8},{2,4,7,9},{2,4,8,9},{2,5,6,7},{2,5,6,8},{2,5,6,9},
                          {2,5,7,8},{2,5,7,9},{2,5,8,9},{2,6,7,8},{2,6,7,9},{2,6,8,9},{2,7,8,9},{3,4,5,6},{3,4,5,7},{3,4,5,8},{3,4,5,9},{3,4,6,7},{3,4,6,8},{3,4,6,9},{3,4,7,8},{3,4,7,9},{3,4,8,9},
                          {3,5,6,7},{3,5,6,8},{3,5,6,9},{3,5,7,8},{3,5,7,9},{3,5,8,9},{3,6,7,8},{3,6,7,9},{3,6,8,9},{3,7,8,9},{4,5,6,7},{4,5,6,8},{4,5,6,9},{4,5,7,8},{4,5,7,9},{4,5,8,9},{4,6,7,8},
                          {4,6,7,9},{4,6,8,9},{4,7,8,9},{5,6,7,8},{5,6,7,9},{5,6,8,9},{5,7,8,9},{6,7,8,9}}},
                    {5, { {1,2,3,4,5},{1,2,3,4,6},{1,2,3,4,7},{1,2,3,4,8},{1,2,3,4,9},{1,2,3,5,6},{1,2,3,5,7},{1,2,3,5,8},{1,2,3,5,9},{1,2,3,6,7},{1,2,3,6,8},{1,2,3,6,9},{1,2,3,7,8},{1,2,3,7,9},
                          {1,2,3,8,9},{1,2,4,5,6},{1,2,4,5,7},{1,2,4,5,8},{1,2,4,5,9},{1,2,4,6,7},{1,2,4,6,8},{1,2,4,6,9},{1,2,4,7,8},{1,2,4,7,9},{1,2,4,8,9},{1,2,5,6,7},{1,2,5,6,8},{1,2,5,6,9},
                          {1,2,5,7,8},{1,2,5,7,9},{1,2,5,8,9},{1,2,6,7,8},{1,2,6,7,9},{1,2,6,8,9},{1,2,7,8,9},{1,3,4,5,6},{1,3,4,5,7},{1,3,4,5,8},{1,3,4,5,9},{1,3,4,6,7},{1,3,4,6,8},{1,3,4,6,9},
                          {1,3,4,7,8},{1,3,4,7,9},{1,3,4,8,9},{1,3,5,6,7},{1,3,5,6,8},{1,3,5,6,9},{1,3,5,7,8},{1,3,5,7,9},{1,3,5,8,9},{1,3,6,7,8},{1,3,6,7,9},{1,3,6,8,9},{1,3,7,8,9},{1,4,5,6,7},
                          {1,4,5,6,8},{1,4,5,6,9},{1,4,5,7,8},{1,4,5,7,9},{1,4,5,8,9},{1,4,6,7,8},{1,4,6,7,9},{1,4,6,8,9},{1,4,7,8,9},{1,5,6,7,8},{1,5,6,7,9},{1,5,6,8,9},{1,5,7,8,9},{1,6,7,8,9},
                          {2,3,4,5,6},{2,3,4,5,7},{2,3,4,5,8},{2,3,4,5,9},{2,3,4,6,7},{2,3,4,6,8},{2,3,4,6,9},{2,3,4,7,8},{2,3,4,7,9},{2,3,4,8,9},{2,3,5,6,7},{2,3,5,6,8},{2,3,5,6,9},{2,3,5,7,8},
                          {2,3,5,7,9},{2,3,5,8,9},{2,3,6,7,8},{2,3,6,7,9},{2,3,6,8,9},{2,3,7,8,9},{2,4,5,6,7},{2,4,5,6,8},{2,4,5,6,9},{2,4,5,7,8},{2,4,5,7,9},{2,4,5,8,9},{2,4,6,7,8},{2,4,6,7,9},
                          {2,4,6,8,9},{2,4,7,8,9},{2,5,6,7,8},{2,5,6,7,9},{2,5,6,8,9},{2,5,7,8,9},{2,6,7,8,9},{3,4,5,6,7},{3,4,5,6,8},{3,4,5,6,9},{3,4,5,7,8},{3,4,5,7,9},{3,4,5,8,9},{3,4,6,7,8},
                          {3,4,6,7,9},{3,4,6,8,9},{3,4,7,8,9},{3,5,6,7,8},{3,5,6,7,9},{3,5,6,8,9},{3,5,7,8,9},{3,6,7,8,9},{4,5,6,7,8},{4,5,6,7,9},{4,5,6,8,9},{4,5,7,8,9},{4,6,7,8,9},{5,6,7,8,9}}},
                    {6, { {1,2,3,4,5,6},{1,2,3,4,5,7},{1,2,3,4,5,8},{1,2,3,4,5,9},{1,2,3,4,6,7},{1,2,3,4,6,8},{1,2,3,4,6,9},{1,2,3,4,7,8},{1,2,3,4,7,9},{1,2,3,4,8,9},{1,2,3,5,6,7},{1,2,3,5,6,8},
                          {1,2,3,5,6,9},{1,2,3,5,7,8},{1,2,3,5,7,9},{1,2,3,5,8,9},{1,2,3,6,7,8},{1,2,3,6,7,9},{1,2,3,6,8,9},{1,2,3,7,8,9},{1,2,4,5,6,7},{1,2,4,5,6,8},{1,2,4,5,6,9},{1,2,4,5,7,8},
                          {1,2,4,5,7,9},{1,2,4,5,8,9},{1,2,4,6,7,8},{1,2,4,6,7,9},{1,2,4,6,8,9},{1,2,4,7,8,9},{1,2,5,6,7,8},{1,2,5,6,7,9},{1,2,5,6,8,9},{1,2,5,7,8,9},{1,2,6,7,8,9},{1,3,4,5,6,7},
                          {1,3,4,5,6,8},{1,3,4,5,6,9},{1,3,4,5,7,8},{1,3,4,5,7,9},{1,3,4,5,8,9},{1,3,4,6,7,8},{1,3,4,6,7,9},{1,3,4,6,8,9},{1,3,4,7,8,9},{1,3,5,6,7,8},{1,3,5,6,7,9},{1,3,5,6,8,9},
                          {1,3,5,7,8,9},{1,3,6,7,8,9},{1,4,5,6,7,8},{1,4,5,6,7,9},{1,4,5,6,8,9},{1,4,5,7,8,9},{1,4,6,7,8,9},{1,5,6,7,8,9},{2,3,4,5,6,7},{2,3,4,5,6,8},{2,3,4,5,6,9},{2,3,4,5,7,8},
                          {2,3,4,5,7,9},{2,3,4,5,8,9},{2,3,4,6,7,8},{2,3,4,6,7,9},{2,3,4,6,8,9},{2,3,4,7,8,9},{2,3,5,6,7,8},{2,3,5,6,7,9},{2,3,5,6,8,9},{2,3,5,7,8,9},{2,3,6,7,8,9},{2,4,5,6,7,8},
                          {2,4,5,6,7,9},{2,4,5,6,8,9},{2,4,5,7,8,9},{2,4,6,7,8,9},{2,5,6,7,8,9},{3,4,5,6,7,8},{3,4,5,6,7,9},{3,4,5,6,8,9},{3,4,5,7,8,9},{3,4,6,7,8,9},{3,5,6,7,8,9},{4,5,6,7,8,9}}},
                    {7, { {1,2,3,4,5,6,7},{1,2,3,4,5,6,8},{1,2,3,4,5,6,9},{1,2,3,4,5,7,8},{1,2,3,4,5,7,9},{1,2,3,4,5,8,9},{1,2,3,4,6,7,8},{1,2,3,4,6,7,9},{1,2,3,4,6,8,9},{1,2,3,4,7,8,9},
                          {1,2,3,5,6,7,8},{1,2,3,5,6,7,9},{1,2,3,5,6,8,9},{1,2,3,5,7,8,9},{1,2,3,6,7,8,9},{1,2,4,5,6,7,8},{1,2,4,5,6,7,9},{1,2,4,5,6,8,9},{1,2,4,5,7,8,9},{1,2,4,6,7,8,9},{1,2,5,6,7,8,9},
                          {1,3,4,5,6,7,8},{1,3,4,5,6,7,9},{1,3,4,5,6,8,9},{1,3,4,5,7,8,9},{1,3,4,6,7,8,9},{1,3,5,6,7,8,9},{1,4,5,6,7,8,9},{2,3,4,5,6,7,8},{2,3,4,5,6,7,9},{2,3,4,5,6,8,9},
                          {2,3,4,5,7,8,9},{2,3,4,6,7,8,9},{2,3,5,6,7,8,9},{2,4,5,6,7,8,9},{3,4,5,6,7,8,9}}},
                    {8, { {1,2,3,4,5,6,7,8},{1,2,3,4,5,6,7,9},{1,2,3,4,5,6,8,9},{1,2,3,4,5,7,8,9},{1,2,3,4,6,7,8,9},{1,2,3,5,6,7,8,9},{1,2,4,5,6,7,8,9},{1,3,4,5,6,7,8,9},{2,3,4,5,6,7,8,9}}},
                    {9, { {1,2,3,4,5,6,7,8,9}}}
            }
        },
        {10, {
                     {1, { {1},{2},{3},{4},{5},{6},{7},{8},{9},{10}}},
                     {2, { {1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{1,9},{1,10},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{2,9},{2,10},{3,4},{3,5},{3,6},{3,7},{3,8},{3,9},{3,10},{4,5},{4,6},{4,7},
                           {4,8},{4,9},{4,10},{5,6},{5,7},{5,8},{5,9},{5,10},{6,7},{6,8},{6,9},{6,10},{7,8},{7,9},{7,10},{8,9},{8,10},{9,10}}},
                     {3, { {1,2,3},{1,2,4},{1,2,5},{1,2,6},{1,2,7},{1,2,8},{1,2,9},{1,2,10},{1,3,4},{1,3,5},{1,3,6},{1,3,7},{1,3,8},{1,3,9},{1,3,10},{1,4,5},{1,4,6},{1,4,7},{1,4,8},{1,4,9},
                           {1,4,10},{1,5,6},{1,5,7},{1,5,8},{1,5,9},{1,5,10},{1,6,7},{1,6,8},{1,6,9},{1,6,10},{1,7,8},{1,7,9},{1,7,10},{1,8,9},{1,8,10},{1,9,10},{2,3,4},{2,3,5},{2,3,6},{2,3,7},{2,3,8},
                           {2,3,9},{2,3,10},{2,4,5},{2,4,6},{2,4,7},{2,4,8},{2,4,9},{2,4,10},{2,5,6},{2,5,7},{2,5,8},{2,5,9},{2,5,10},{2,6,7},{2,6,8},{2,6,9},{2,6,10},{2,7,8},{2,7,9},{2,7,10},{2,8,9},
                           {2,8,10},{2,9,10},{3,4,5},{3,4,6},{3,4,7},{3,4,8},{3,4,9},{3,4,10},{3,5,6},{3,5,7},{3,5,8},{3,5,9},{3,5,10},{3,6,7},{3,6,8},{3,6,9},{3,6,10},{3,7,8},{3,7,9},{3,7,10},{3,8,9},
                           {3,8,10},{3,9,10},{4,5,6},{4,5,7},{4,5,8},{4,5,9},{4,5,10},{4,6,7},{4,6,8},{4,6,9},{4,6,10},{4,7,8},{4,7,9},{4,7,10},{4,8,9},{4,8,10},{4,9,10},{5,6,7},{5,6,8},{5,6,9},{5,6,10},
                           {5,7,8},{5,7,9},{5,7,10},{5,8,9},{5,8,10},{5,9,10},{6,7,8},{6,7,9},{6,7,10},{6,8,9},{6,8,10},{6,9,10},{7,8,9},{7,8,10},{7,9,10},{8,9,10}}},
                     {4, { {1,2,3,4},{1,2,3,5},{1,2,3,6},{1,2,3,7},{1,2,3,8},{1,2,3,9},{1,2,3,10},{1,2,4,5},{1,2,4,6},{1,2,4,7},{1,2,4,8},{1,2,4,9},{1,2,4,10},{1,2,5,6},{1,2,5,7},{1,2,5,8},{1,2,5,9},
                           {1,2,5,10},{1,2,6,7},{1,2,6,8},{1,2,6,9},{1,2,6,10},{1,2,7,8},{1,2,7,9},{1,2,7,10},{1,2,8,9},{1,2,8,10},{1,2,9,10},{1,3,4,5},{1,3,4,6},{1,3,4,7},{1,3,4,8},{1,3,4,9},{1,3,4,10},
                           {1,3,5,6},{1,3,5,7},{1,3,5,8},{1,3,5,9},{1,3,5,10},{1,3,6,7},{1,3,6,8},{1,3,6,9},{1,3,6,10},{1,3,7,8},{1,3,7,9},{1,3,7,10},{1,3,8,9},{1,3,8,10},{1,3,9,10},{1,4,5,6},{1,4,5,7},
                           {1,4,5,8},{1,4,5,9},{1,4,5,10},{1,4,6,7},{1,4,6,8},{1,4,6,9},{1,4,6,10},{1,4,7,8},{1,4,7,9},{1,4,7,10},{1,4,8,9},{1,4,8,10},{1,4,9,10},{1,5,6,7},{1,5,6,8},{1,5,6,9},{1,5,6,10},
                           {1,5,7,8},{1,5,7,9},{1,5,7,10},{1,5,8,9},{1,5,8,10},{1,5,9,10},{1,6,7,8},{1,6,7,9},{1,6,7,10},{1,6,8,9},{1,6,8,10},{1,6,9,10},{1,7,8,9},{1,7,8,10},{1,7,9,10},{1,8,9,10},{2,3,4,5},
                           {2,3,4,6},{2,3,4,7},{2,3,4,8},{2,3,4,9},{2,3,4,10},{2,3,5,6},{2,3,5,7},{2,3,5,8},{2,3,5,9},{2,3,5,10},{2,3,6,7},{2,3,6,8},{2,3,6,9},{2,3,6,10},{2,3,7,8},{2,3,7,9},{2,3,7,10},
                           {2,3,8,9},{2,3,8,10},{2,3,9,10},{2,4,5,6},{2,4,5,7},{2,4,5,8},{2,4,5,9},{2,4,5,10},{2,4,6,7},{2,4,6,8},{2,4,6,9},{2,4,6,10},{2,4,7,8},{2,4,7,9},{2,4,7,10},{2,4,8,9},{2,4,8,10},
                           {2,4,9,10},{2,5,6,7},{2,5,6,8},{2,5,6,9},{2,5,6,10},{2,5,7,8},{2,5,7,9},{2,5,7,10},{2,5,8,9},{2,5,8,10},{2,5,9,10},{2,6,7,8},{2,6,7,9},{2,6,7,10},{2,6,8,9},{2,6,8,10},{2,6,9,10},
                           {2,7,8,9},{2,7,8,10},{2,7,9,10},{2,8,9,10},{3,4,5,6},{3,4,5,7},{3,4,5,8},{3,4,5,9},{3,4,5,10},{3,4,6,7},{3,4,6,8},{3,4,6,9},{3,4,6,10},{3,4,7,8},{3,4,7,9},{3,4,7,10},{3,4,8,9},
                           {3,4,8,10},{3,4,9,10},{3,5,6,7},{3,5,6,8},{3,5,6,9},{3,5,6,10},{3,5,7,8},{3,5,7,9},{3,5,7,10},{3,5,8,9},{3,5,8,10},{3,5,9,10},{3,6,7,8},{3,6,7,9},{3,6,7,10},{3,6,8,9},{3,6,8,10},
                           {3,6,9,10},{3,7,8,9},{3,7,8,10},{3,7,9,10},{3,8,9,10},{4,5,6,7},{4,5,6,8},{4,5,6,9},{4,5,6,10},{4,5,7,8},{4,5,7,9},{4,5,7,10},{4,5,8,9},{4,5,8,10},{4,5,9,10},{4,6,7,8},{4,6,7,9},
                           {4,6,7,10},{4,6,8,9},{4,6,8,10},{4,6,9,10},{4,7,8,9},{4,7,8,10},{4,7,9,10},{4,8,9,10},{5,6,7,8},{5,6,7,9},{5,6,7,10},{5,6,8,9},{5,6,8,10},{5,6,9,10},{5,7,8,9},{5,7,8,10},{5,7,9,10},
                           {5,8,9,10},{6,7,8,9},{6,7,8,10},{6,7,9,10},{6,8,9,10},{7,8,9,10}}},
                     {5, { {1,2,3,4,5},{1,2,3,4,6},{1,2,3,4,7},{1,2,3,4,8},{1,2,3,4,9},{1,2,3,4,10},{1,2,3,5,6},{1,2,3,5,7},{1,2,3,5,8},{1,2,3,5,9},{1,2,3,5,10},{1,2,3,6,7},{1,2,3,6,8},{1,2,3,6,9},
                           {1,2,3,6,10},{1,2,3,7,8},{1,2,3,7,9},{1,2,3,7,10},{1,2,3,8,9},{1,2,3,8,10},{1,2,3,9,10},{1,2,4,5,6},{1,2,4,5,7},{1,2,4,5,8},{1,2,4,5,9},{1,2,4,5,10},{1,2,4,6,7},{1,2,4,6,8},
                           {1,2,4,6,9},{1,2,4,6,10},{1,2,4,7,8},{1,2,4,7,9},{1,2,4,7,10},{1,2,4,8,9},{1,2,4,8,10},{1,2,4,9,10},{1,2,5,6,7},{1,2,5,6,8},{1,2,5,6,9},{1,2,5,6,10},{1,2,5,7,8},{1,2,5,7,9},
                           {1,2,5,7,10},{1,2,5,8,9},{1,2,5,8,10},{1,2,5,9,10},{1,2,6,7,8},{1,2,6,7,9},{1,2,6,7,10},{1,2,6,8,9},{1,2,6,8,10},{1,2,6,9,10},{1,2,7,8,9},{1,2,7,8,10},{1,2,7,9,10},{1,2,8,9,10},
                           {1,3,4,5,6},{1,3,4,5,7},{1,3,4,5,8},{1,3,4,5,9},{1,3,4,5,10},{1,3,4,6,7},{1,3,4,6,8},{1,3,4,6,9},{1,3,4,6,10},{1,3,4,7,8},{1,3,4,7,9},{1,3,4,7,10},{1,3,4,8,9},{1,3,4,8,10},
                           {1,3,4,9,10},{1,3,5,6,7},{1,3,5,6,8},{1,3,5,6,9},{1,3,5,6,10},{1,3,5,7,8},{1,3,5,7,9},{1,3,5,7,10},{1,3,5,8,9},{1,3,5,8,10},{1,3,5,9,10},{1,3,6,7,8},{1,3,6,7,9},{1,3,6,7,10},
                           {1,3,6,8,9},{1,3,6,8,10},{1,3,6,9,10},{1,3,7,8,9},{1,3,7,8,10},{1,3,7,9,10},{1,3,8,9,10},{1,4,5,6,7},{1,4,5,6,8},{1,4,5,6,9},{1,4,5,6,10},{1,4,5,7,8},{1,4,5,7,9},{1,4,5,7,10},
                           {1,4,5,8,9},{1,4,5,8,10},{1,4,5,9,10},{1,4,6,7,8},{1,4,6,7,9},{1,4,6,7,10},{1,4,6,8,9},{1,4,6,8,10},{1,4,6,9,10},{1,4,7,8,9},{1,4,7,8,10},{1,4,7,9,10},{1,4,8,9,10},{1,5,6,7,8},
                           {1,5,6,7,9},{1,5,6,7,10},{1,5,6,8,9},{1,5,6,8,10},{1,5,6,9,10},{1,5,7,8,9},{1,5,7,8,10},{1,5,7,9,10},{1,5,8,9,10},{1,6,7,8,9},{1,6,7,8,10},{1,6,7,9,10},{1,6,8,9,10},{1,7,8,9,10},
                           {2,3,4,5,6},{2,3,4,5,7},{2,3,4,5,8},{2,3,4,5,9},{2,3,4,5,10},{2,3,4,6,7},{2,3,4,6,8},{2,3,4,6,9},{2,3,4,6,10},{2,3,4,7,8},{2,3,4,7,9},{2,3,4,7,10},{2,3,4,8,9},{2,3,4,8,10},
                           {2,3,4,9,10},{2,3,5,6,7},{2,3,5,6,8},{2,3,5,6,9},{2,3,5,6,10},{2,3,5,7,8},{2,3,5,7,9},{2,3,5,7,10},{2,3,5,8,9},{2,3,5,8,10},{2,3,5,9,10},{2,3,6,7,8},{2,3,6,7,9},{2,3,6,7,10},
                           {2,3,6,8,9},{2,3,6,8,10},{2,3,6,9,10},{2,3,7,8,9},{2,3,7,8,10},{2,3,7,9,10},{2,3,8,9,10},{2,4,5,6,7},{2,4,5,6,8},{2,4,5,6,9},{2,4,5,6,10},{2,4,5,7,8},{2,4,5,7,9},{2,4,5,7,10},
                           {2,4,5,8,9},{2,4,5,8,10},{2,4,5,9,10},{2,4,6,7,8},{2,4,6,7,9},{2,4,6,7,10},{2,4,6,8,9},{2,4,6,8,10},{2,4,6,9,10},{2,4,7,8,9},{2,4,7,8,10},{2,4,7,9,10},{2,4,8,9,10},{2,5,6,7,8},
                           {2,5,6,7,9},{2,5,6,7,10},{2,5,6,8,9},{2,5,6,8,10},{2,5,6,9,10},{2,5,7,8,9},{2,5,7,8,10},{2,5,7,9,10},{2,5,8,9,10},{2,6,7,8,9},{2,6,7,8,10},{2,6,7,9,10},{2,6,8,9,10},{2,7,8,9,10},
                           {3,4,5,6,7},{3,4,5,6,8},{3,4,5,6,9},{3,4,5,6,10},{3,4,5,7,8},{3,4,5,7,9},{3,4,5,7,10},{3,4,5,8,9},{3,4,5,8,10},{3,4,5,9,10},{3,4,6,7,8},{3,4,6,7,9},{3,4,6,7,10},{3,4,6,8,9},
                           {3,4,6,8,10},{3,4,6,9,10},{3,4,7,8,9},{3,4,7,8,10},{3,4,7,9,10},{3,4,8,9,10},{3,5,6,7,8},{3,5,6,7,9},{3,5,6,7,10},{3,5,6,8,9},{3,5,6,8,10},{3,5,6,9,10},{3,5,7,8,9},{3,5,7,8,10},
                           {3,5,7,9,10},{3,5,8,9,10},{3,6,7,8,9},{3,6,7,8,10},{3,6,7,9,10},{3,6,8,9,10},{3,7,8,9,10},{4,5,6,7,8},{4,5,6,7,9},{4,5,6,7,10},{4,5,6,8,9},{4,5,6,8,10},{4,5,6,9,10},{4,5,7,8,9},
                           {4,5,7,8,10},{4,5,7,9,10},{4,5,8,9,10},{4,6,7,8,9},{4,6,7,8,10},{4,6,7,9,10},{4,6,8,9,10},{4,7,8,9,10},{5,6,7,8,9},{5,6,7,8,10},{5,6,7,9,10},{5,6,8,9,10},{5,7,8,9,10},{6,7,8,9,10}}},
                     {6, { {1,2,3,4,5,6},{1,2,3,4,5,7},{1,2,3,4,5,8},{1,2,3,4,5,9},{1,2,3,4,5,10},{1,2,3,4,6,7},{1,2,3,4,6,8},{1,2,3,4,6,9},{1,2,3,4,6,10},{1,2,3,4,7,8},{1,2,3,4,7,9},{1,2,3,4,7,10},
                           {1,2,3,4,8,9},{1,2,3,4,8,10},{1,2,3,4,9,10},{1,2,3,5,6,7},{1,2,3,5,6,8},{1,2,3,5,6,9},{1,2,3,5,6,10},{1,2,3,5,7,8},{1,2,3,5,7,9},{1,2,3,5,7,10},{1,2,3,5,8,9},{1,2,3,5,8,10},
                           {1,2,3,5,9,10},{1,2,3,6,7,8},{1,2,3,6,7,9},{1,2,3,6,7,10},{1,2,3,6,8,9},{1,2,3,6,8,10},{1,2,3,6,9,10},{1,2,3,7,8,9},{1,2,3,7,8,10},{1,2,3,7,9,10},{1,2,3,8,9,10},{1,2,4,5,6,7},
                           {1,2,4,5,6,8},{1,2,4,5,6,9},{1,2,4,5,6,10},{1,2,4,5,7,8},{1,2,4,5,7,9},{1,2,4,5,7,10},{1,2,4,5,8,9},{1,2,4,5,8,10},{1,2,4,5,9,10},{1,2,4,6,7,8},{1,2,4,6,7,9},{1,2,4,6,7,10},
                           {1,2,4,6,8,9},{1,2,4,6,8,10},{1,2,4,6,9,10},{1,2,4,7,8,9},{1,2,4,7,8,10},{1,2,4,7,9,10},{1,2,4,8,9,10},{1,2,5,6,7,8},{1,2,5,6,7,9},{1,2,5,6,7,10},{1,2,5,6,8,9},{1,2,5,6,8,10},
                           {1,2,5,6,9,10},{1,2,5,7,8,9},{1,2,5,7,8,10},{1,2,5,7,9,10},{1,2,5,8,9,10},{1,2,6,7,8,9},{1,2,6,7,8,10},{1,2,6,7,9,10},{1,2,6,8,9,10},{1,2,7,8,9,10},{1,3,4,5,6,7},{1,3,4,5,6,8},
                           {1,3,4,5,6,9},{1,3,4,5,6,10},{1,3,4,5,7,8},{1,3,4,5,7,9},{1,3,4,5,7,10},{1,3,4,5,8,9},{1,3,4,5,8,10},{1,3,4,5,9,10},{1,3,4,6,7,8},{1,3,4,6,7,9},{1,3,4,6,7,10},{1,3,4,6,8,9},
                           {1,3,4,6,8,10},{1,3,4,6,9,10},{1,3,4,7,8,9},{1,3,4,7,8,10},{1,3,4,7,9,10},{1,3,4,8,9,10},{1,3,5,6,7,8},{1,3,5,6,7,9},{1,3,5,6,7,10},{1,3,5,6,8,9},{1,3,5,6,8,10},{1,3,5,6,9,10},
                           {1,3,5,7,8,9},{1,3,5,7,8,10},{1,3,5,7,9,10},{1,3,5,8,9,10},{1,3,6,7,8,9},{1,3,6,7,8,10},{1,3,6,7,9,10},{1,3,6,8,9,10},{1,3,7,8,9,10},{1,4,5,6,7,8},{1,4,5,6,7,9},{1,4,5,6,7,10},
                           {1,4,5,6,8,9},{1,4,5,6,8,10},{1,4,5,6,9,10},{1,4,5,7,8,9},{1,4,5,7,8,10},{1,4,5,7,9,10},{1,4,5,8,9,10},{1,4,6,7,8,9},{1,4,6,7,8,10},{1,4,6,7,9,10},{1,4,6,8,9,10},{1,4,7,8,9,10},
                           {1,5,6,7,8,9},{1,5,6,7,8,10},{1,5,6,7,9,10},{1,5,6,8,9,10},{1,5,7,8,9,10},{1,6,7,8,9,10},{2,3,4,5,6,7},{2,3,4,5,6,8},{2,3,4,5,6,9},{2,3,4,5,6,10},{2,3,4,5,7,8},{2,3,4,5,7,9},
                           {2,3,4,5,7,10},{2,3,4,5,8,9},{2,3,4,5,8,10},{2,3,4,5,9,10},{2,3,4,6,7,8},{2,3,4,6,7,9},{2,3,4,6,7,10},{2,3,4,6,8,9},{2,3,4,6,8,10},{2,3,4,6,9,10},{2,3,4,7,8,9},{2,3,4,7,8,10},
                           {2,3,4,7,9,10},{2,3,4,8,9,10},{2,3,5,6,7,8},{2,3,5,6,7,9},{2,3,5,6,7,10},{2,3,5,6,8,9},{2,3,5,6,8,10},{2,3,5,6,9,10},{2,3,5,7,8,9},{2,3,5,7,8,10},{2,3,5,7,9,10},{2,3,5,8,9,10},
                           {2,3,6,7,8,9},{2,3,6,7,8,10},{2,3,6,7,9,10},{2,3,6,8,9,10},{2,3,7,8,9,10},{2,4,5,6,7,8},{2,4,5,6,7,9},{2,4,5,6,7,10},{2,4,5,6,8,9},{2,4,5,6,8,10},{2,4,5,6,9,10},{2,4,5,7,8,9},
                           {2,4,5,7,8,10},{2,4,5,7,9,10},{2,4,5,8,9,10},{2,4,6,7,8,9},{2,4,6,7,8,10},{2,4,6,7,9,10},{2,4,6,8,9,10},{2,4,7,8,9,10},{2,5,6,7,8,9},{2,5,6,7,8,10},{2,5,6,7,9,10},{2,5,6,8,9,10},
                           {2,5,7,8,9,10},{2,6,7,8,9,10},{3,4,5,6,7,8},{3,4,5,6,7,9},{3,4,5,6,7,10},{3,4,5,6,8,9},{3,4,5,6,8,10},{3,4,5,6,9,10},{3,4,5,7,8,9},{3,4,5,7,8,10},{3,4,5,7,9,10},{3,4,5,8,9,10},
                           {3,4,6,7,8,9},{3,4,6,7,8,10},{3,4,6,7,9,10},{3,4,6,8,9,10},{3,4,7,8,9,10},{3,5,6,7,8,9},{3,5,6,7,8,10},{3,5,6,7,9,10},{3,5,6,8,9,10},{3,5,7,8,9,10},{3,6,7,8,9,10},{4,5,6,7,8,9},
                           {4,5,6,7,8,10},{4,5,6,7,9,10},{4,5,6,8,9,10},{4,5,7,8,9,10},{4,6,7,8,9,10},{5,6,7,8,9,10}}},
                     {7, { {1,2,3,4,5,6,7},{1,2,3,4,5,6,8},{1,2,3,4,5,6,9},{1,2,3,4,5,6,10},{1,2,3,4,5,7,8},{1,2,3,4,5,7,9},{1,2,3,4,5,7,10},{1,2,3,4,5,8,9},{1,2,3,4,5,8,10},{1,2,3,4,5,9,10},
                           {1,2,3,4,6,7,8},{1,2,3,4,6,7,9},{1,2,3,4,6,7,10},{1,2,3,4,6,8,9},{1,2,3,4,6,8,10},{1,2,3,4,6,9,10},{1,2,3,4,7,8,9},{1,2,3,4,7,8,10},{1,2,3,4,7,9,10},{1,2,3,4,8,9,10},
                           {1,2,3,5,6,7,8},{1,2,3,5,6,7,9},{1,2,3,5,6,7,10},{1,2,3,5,6,8,9},{1,2,3,5,6,8,10},{1,2,3,5,6,9,10},{1,2,3,5,7,8,9},{1,2,3,5,7,8,10},{1,2,3,5,7,9,10},{1,2,3,5,8,9,10},
                           {1,2,3,6,7,8,9},{1,2,3,6,7,8,10},{1,2,3,6,7,9,10},{1,2,3,6,8,9,10},{1,2,3,7,8,9,10},{1,2,4,5,6,7,8},{1,2,4,5,6,7,9},{1,2,4,5,6,7,10},{1,2,4,5,6,8,9},{1,2,4,5,6,8,10},
                           {1,2,4,5,6,9,10},{1,2,4,5,7,8,9},{1,2,4,5,7,8,10},{1,2,4,5,7,9,10},{1,2,4,5,8,9,10},{1,2,4,6,7,8,9},{1,2,4,6,7,8,10},{1,2,4,6,7,9,10},{1,2,4,6,8,9,10},{1,2,4,7,8,9,10},
                           {1,2,5,6,7,8,9},{1,2,5,6,7,8,10},{1,2,5,6,7,9,10},{1,2,5,6,8,9,10},{1,2,5,7,8,9,10},{1,2,6,7,8,9,10},{1,3,4,5,6,7,8},{1,3,4,5,6,7,9},{1,3,4,5,6,7,10},{1,3,4,5,6,8,9},
                           {1,3,4,5,6,8,10},{1,3,4,5,6,9,10},{1,3,4,5,7,8,9},{1,3,4,5,7,8,10},{1,3,4,5,7,9,10},{1,3,4,5,8,9,10},{1,3,4,6,7,8,9},{1,3,4,6,7,8,10},{1,3,4,6,7,9,10},{1,3,4,6,8,9,10},
                           {1,3,4,7,8,9,10},{1,3,5,6,7,8,9},{1,3,5,6,7,8,10},{1,3,5,6,7,9,10},{1,3,5,6,8,9,10},{1,3,5,7,8,9,10},{1,3,6,7,8,9,10},{1,4,5,6,7,8,9},{1,4,5,6,7,8,10},{1,4,5,6,7,9,10},
                           {1,4,5,6,8,9,10},{1,4,5,7,8,9,10},{1,4,6,7,8,9,10},{1,5,6,7,8,9,10},{2,3,4,5,6,7,8},{2,3,4,5,6,7,9},{2,3,4,5,6,7,10},{2,3,4,5,6,8,9},{2,3,4,5,6,8,10},{2,3,4,5,6,9,10},
                           {2,3,4,5,7,8,9},{2,3,4,5,7,8,10},{2,3,4,5,7,9,10},{2,3,4,5,8,9,10},{2,3,4,6,7,8,9},{2,3,4,6,7,8,10},{2,3,4,6,7,9,10},{2,3,4,6,8,9,10},{2,3,4,7,8,9,10},{2,3,5,6,7,8,9},
                           {2,3,5,6,7,8,10},{2,3,5,6,7,9,10},{2,3,5,6,8,9,10},{2,3,5,7,8,9,10},{2,3,6,7,8,9,10},{2,4,5,6,7,8,9},{2,4,5,6,7,8,10},{2,4,5,6,7,9,10},{2,4,5,6,8,9,10},{2,4,5,7,8,9,10},
                           {2,4,6,7,8,9,10},{2,5,6,7,8,9,10},{3,4,5,6,7,8,9},{3,4,5,6,7,8,10},{3,4,5,6,7,9,10},{3,4,5,6,8,9,10},{3,4,5,7,8,9,10},{3,4,6,7,8,9,10},{3,5,6,7,8,9,10},{4,5,6,7,8,9,10}}},
                     {8, { {1,2,3,4,5,6,7,8},{1,2,3,4,5,6,7,9},{1,2,3,4,5,6,7,10},{1,2,3,4,5,6,8,9},{1,2,3,4,5,6,8,10},{1,2,3,4,5,6,9,10},{1,2,3,4,5,7,8,9},{1,2,3,4,5,7,8,10},{1,2,3,4,5,7,9,10},
                           {1,2,3,4,5,8,9,10},{1,2,3,4,6,7,8,9},{1,2,3,4,6,7,8,10},{1,2,3,4,6,7,9,10},{1,2,3,4,6,8,9,10},{1,2,3,4,7,8,9,10},{1,2,3,5,6,7,8,9},{1,2,3,5,6,7,8,10},{1,2,3,5,6,7,9,10},
                           {1,2,3,5,6,8,9,10},{1,2,3,5,7,8,9,10},{1,2,3,6,7,8,9,10},{1,2,4,5,6,7,8,9},{1,2,4,5,6,7,8,10},{1,2,4,5,6,7,9,10},{1,2,4,5,6,8,9,10},{1,2,4,5,7,8,9,10},{1,2,4,6,7,8,9,10},
                           {1,2,5,6,7,8,9,10},{1,3,4,5,6,7,8,9},{1,3,4,5,6,7,8,10},{1,3,4,5,6,7,9,10},{1,3,4,5,6,8,9,10},{1,3,4,5,7,8,9,10},{1,3,4,6,7,8,9,10},{1,3,5,6,7,8,9,10},{1,4,5,6,7,8,9,10},
                           {2,3,4,5,6,7,8,9},{2,3,4,5,6,7,8,10},{2,3,4,5,6,7,9,10},{2,3,4,5,6,8,9,10},{2,3,4,5,7,8,9,10},{2,3,4,6,7,8,9,10},{2,3,5,6,7,8,9,10},{2,4,5,6,7,8,9,10},{3,4,5,6,7,8,9,10}}},
                     {9, { {1,2,3,4,5,6,7,8,9},{1,2,3,4,5,6,7,8,10},{1,2,3,4,5,6,7,9,10},{1,2,3,4,5,6,8,9,10},{1,2,3,4,5,7,8,9,10},{1,2,3,4,6,7,8,9,10},{1,2,3,5,6,7,8,9,10},{1,2,4,5,6,7,8,9,10},
                           {1,3,4,5,6,7,8,9,10},{2,3,4,5,6,7,8,9,10}}},
                     {10, { {1,2,3,4,5,6,7,8,9,10}}}
            }
        }
};

/*!
 * Dynamic Program to search all the available sequential cluster sizes for a Chain C of length K
 * @param k small k is starting point, from which you have to calculate, as some will be precalculated and saved.
 * @param K chain length which is maxSFClen, that is upto what you want to calculate all possible enumeration
 * @param showInConsole to show the output in console. Time will increase to 2000-2500 ms
 * @return updated clusterSz[i] for k <= i <=K.\n
 *  K[1] total(1), {{1}} \n
 *  K[2] total(2), {{1,1},{2}} \n
 *  K[3] total(4), {{1,1,1},{2,1},{1,2},{3}} \n
 *  K[4] total(8), {{1,1,1,1},{2,1,1},{1,2,1},{3,1},{1,1,2},{2,2},{1,3},{4}}
 */
void clusterSizeEnumeration(unsigned int k, unsigned int K, bool showInConsole=false) {
    if(k>K) return;
    if(clusterSz.find(k-1) == clusterSz.end()){
        string errorMsg = "Previous Cluster size k-1="+to_string(k-1)+ " does not exist. Caclculate that first. Function: ";
        throw runtime_error(errorMsg+ __FUNCTION__);
    }
//    vector<vector<vector<int>>> clusterSz(K+1);
    for(unsigned int ki = k; ki<=K; ki++){
        vector<vector<unsigned int>> ans;
        for(unsigned int i=1; i<=ki; i++){
            for(auto s_dash: clusterSz[ki-i]){
                s_dash.push_back(i);
                ans.push_back(s_dash);
            }
        }
        clusterSz[ki] = std::move(ans);
    }

    if(showInConsole){
        cout<<"\nclusterSize={";
        for(unsigned int ki = k; ki<=K; ki++){
            cout<<"\n\tK["<<ki<<"] total("<<clusterSz[ki].size()<<"), {";
            for(const auto& x: clusterSz[ki]) {
                cout<<"{"; for(unsigned int i=0; i<x.size()-1; i++) cout<<x[i]<<","; cout<<x[x.size()-1]<<"},";
            }  cout<<"}";
        } cout<<"\n}end;";
    }
}

/*! Calculate all possible combination vectors n Choose k for given n and k.
 * @param n starting point from which you have to calculate new value, as some will be precalculated and saved.
 * @param N maximum value upto which you want to calculate all possible combination
 * @param showInConsole  to show the output in console. Time will increase to 2000-2500 ms
 * @return updated nCk[i] for n <= i <=N.\n
 *      n=1, {k=1, [1] }\n
 *      n=2, {k=1, [{1},{2}]  |         k=2, [{1,2}]   }\n
 *      n=3, {k=1, [{1},{2},{3} |       k=2, [{1,2},{1,3},{2,3}] | {k=3, [{1,2,3}] }\n
 *      n=4, {k=1, [{1},{2},{3},{4}] |  k=2, [{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}] | {k=3, [{1,2,3},{1,2,4},{1,3,4}, {2,3,4}] | k=4, [{1,2,3,4}] }
 */
void all_nCk(unsigned int n, unsigned int N, bool showInConsole=false){
    if(n>N) return;
    // Lambda Function to calculate nCk using backtracking application.
    std::function<void(unsigned int,unsigned int,vector<unsigned int>&,unsigned int&,unsigned int&)> combineHelper = [&combineHelper]
    (unsigned int st, unsigned int k, vector<unsigned int>& cur, unsigned int &x, unsigned int &y) ->void
    {
        if(k==0) {
            nCk[x][y].push_back(cur);
            return;
        }
        for(unsigned int value=st; value <= x-k+1; value++) {
            cur.push_back(value);
            combineHelper(value+1, k-1, cur, x, y);
            cur.pop_back();
        }
    };

    for(unsigned int ni=n; ni<=N; ni++){
        for(unsigned int kr=1; kr<=ni; kr++){
            vector<unsigned int> cur;
            combineHelper(1, kr, cur, ni, kr);
        }
    }
    if(showInConsole){
        cout<<"\nnCk={";
        for(unsigned int ni=n; ni<=N; ni++){
            cout<<"\n\tN["<<ni<<"]"<<", {";
            for(unsigned int kr=1; kr<=ni; kr++){
                cout<<"\n\t\tk["<<kr<<"], { ";
                for(auto vec: nCk[ni][kr] ) {
                    cout<<"{"; for(unsigned int i=0; i<vec.size()-1; i++) cout<<vec[i]<<","; cout<<vec[vec.size()-1]<<"},";
                }
                cout<<"}";
            }
            cout<<"\n\t}";
        }cout<<"\n}end;";
    }
}

/*! It reads data from sequential vector and then convert into full Parallel SFC (parallel VNF blocks) chain by detecting whether two function can be parallelised or not.\n
 * Each block denote fully parallel VNFs in that step.
 * @param SFC ServiceFunctionChain object to convert sequential into parallel.
 * @param VNFNetwork object of VirtualNetworkFunctions class required to check two vnf are parallelizable or not.
 */
template<typename type_res=unsigned int>
void convertSeqSFC_to_FullParVNFBlocks(ServiceFunctionChain* SFC, VirtualNetworkFunctions<type_res> *VNFNetwork, bool isLast=false){
    unsigned int sz = SFC->vnfSeq.size(); // total vnfs including src and dest
//    SFC->vnfBlocksPar.push_back({SFCsrc}); // stage 0, pushing src node
    for(int cid=1; cid<sz-1; cid++){ // from SFCsrc+1 stg to SFCdst-1 stage
        unsigned int prv_vnf = SFC->vnfSeq[cid-1], cur_vnf = SFC->vnfSeq[cid];  // Checking prv_vnf --> cur_vnf pairs
        // NOT PARALLEL, if prv_vnf does not exist as first vnf in pair or if prv_vnf exist it is not parallel to cur_vnf, then it is not parallel pair
        if(VNFNetwork->parallelPairs.count(prv_vnf)==0 or VNFNetwork->parallelPairs[prv_vnf].find(cur_vnf) == VNFNetwork->parallelPairs[prv_vnf].end()){
            SFC->vnfBlocksPar.push_back({cur_vnf});// push cur_vnf as separte new stage
        }else if(SFC->vnfBlocksPar.back().size() == 1) { //PARALLEL Pairs STG Size=1 and size of previous stg is just one, then we can directly push into that stg.
            SFC->vnfBlocksPar.back().push_back(cur_vnf);
        }else{ // PARALLEL Pairs and STG size > 1, from previous stg we have to check if cur_vnf is parallel to all prv_vnf in previous stage
            bool pushInLstStg = true;
            for(const unsigned int& lst_stg_vnf: SFC->vnfBlocksPar.back()){
                if(VNFNetwork->parallelPairs.count(lst_stg_vnf)==0 or VNFNetwork->parallelPairs[lst_stg_vnf].find(cur_vnf) == VNFNetwork->parallelPairs[lst_stg_vnf].end()){
                    pushInLstStg = false;   break;
                }
            }
            if(pushInLstStg) SFC->vnfBlocksPar.back().push_back(cur_vnf);
            else SFC->vnfBlocksPar.push_back({cur_vnf});
        }//lst stg size>1
    }// for cid
    if(debug and isLast)cout<<"\n\t[SFCs converted to Full Parallel VNFs Blocks]";
}

/*! generate all the feasible partial parallel SFC for the given full parallel SFC.
 * @param nVNFs is number of VNFs except src and dest in fully parallel SFC.
 * @param clusterSz for each of the cluster enumeration for size[nVNFs].
 * @param nCk n=block size and k={cluster_i[l] value i.e. l(level) index value dentoes number of function(k) to be chosen as parallel out of all functions(n) in blocks.
 * @param fullParVNFBlocks is fully parallel VNF Blocks in sequence where each block/step denotes all the parallelizable functions in that block/step.
 * @return allPartParSFC All the Partial parallel Clusters of the fully parallel VNF Blocks. Each SFC is without src and dest.
 * @ForExample: fullParVNFBlocks={{1},{2,3,4,5}}, nVNFs:5 (f1,f2,f3,f4,f5).\n
 * Blk(0) = {1} only 1 parallel function, Blk(1) = {2,3,4,5} all 4 are parallel.\n
 * clusterSz[5(size=nVNFs)] = {{1, 2,1,1},{1,4},{3,1,1} ... } so on. cluster_i[l] denotes number of function parallel in that level. \n
 * where cluster_i {1, 2, 1, 1} means in level[0] only one function runs, level[2] = 2 functions run together, and level[3] and level[4] one-one function are there \n
 * {[1], [2,1,1]} is mapped to {[f1], [f2,f3,f4,f4]} such that [ 1-c combination of f1 ]-> [2-c combination of f2,f3,f4,f5] -> [1-c combination of f2,f3,f4,f5] -> [1-c combination of f2,f3,f4,f5] \n
 */
void parVNFBlocks_ClusterAssignment_ForSFC(ServiceFunctionChain* SFC, bool showInConsole = false, bool showInConsoleDetailed = false){
    const vector<vector<unsigned int>>& fullParVNFBlocks = SFC->vnfBlocksPar;
    const unsigned int& nBlk = fullParVNFBlocks.size(); ///< number of blocks of the fully parallel SFC, (including src and dst block)
    vector<vector<vector<unsigned int>>>& allPartParSFC = SFC->allPartParSFC; ///< All the Partial parallel Clusters of the fully parallel VNF Blocks. Each SFC is without src and dest.
//    const vector<vector<unsigned int>> SK = { {1,  2,1,1},{1, 2,2}, {1,4}, {2,2,1}, {3,1,1} };

    /// lambda backtrack function to find all partial sfc corresponding to cluster_i and parSFC_Full.
    std::function<void(unsigned int,vector<vector<unsigned int>>&,unordered_map<unsigned int,vector<unsigned int>>&, unsigned int&)> findAllPartSFC_Backtrack
            =[&findAllPartSFC_Backtrack, &allPartParSFC, &fullParVNFBlocks]
            (unsigned int cur_level_idx, vector<vector<unsigned int>>&partSFC, unordered_map<unsigned int,vector<unsigned int>>& levelInfo, unsigned int& mask) ->void
    {
        // if current level is equal to total level in cluster/SFC.
        if(cur_level_idx == levelInfo.size()) {
            allPartParSFC.push_back(partSFC);
            return;
        }

        unsigned int blkid = levelInfo[cur_level_idx][0], nl = levelInfo[cur_level_idx][1], kl= levelInfo[cur_level_idx][2];
        for(const vector<unsigned int>& curCombination: nCk[nl][kl]){ //n=4,k=1 {{1}, {2}, {3}, {4}} } | k=2 {{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}} }
            bool thisCombinationCanBeVisited = true;

            vector<unsigned int> curBlkFunc; //< if we can visit this combination then this vector will be current blk
            unsigned int localMask=0;
            for(const unsigned int& idx: curCombination){ // check if the curCombination idx{2,3} mapped to block func {fw (id 1-1), fx (id 2-1), fy (id 3-1)} --> fx, fy can be visited or its node already visited.
                int fn_id = fullParVNFBlocks[blkid][idx-1];
                if((mask & (1<<fn_id)) != 0){ thisCombinationCanBeVisited=false; break; }
                curBlkFunc.push_back(fn_id);
                localMask |= (1<<fn_id);
            }
            if(thisCombinationCanBeVisited){
                mask |= localMask;
                partSFC.push_back(std::move(curBlkFunc));
                findAllPartSFC_Backtrack(cur_level_idx+1, partSFC, levelInfo, mask);
                mask ^= localMask;
                partSFC.pop_back();
            }
        }
    };


    if(showInConsole and showInConsoleDetailed){
        SFC->showSFC_BlockWise(SFCpar, SFC->I_VNFType2Inst);
    }
    for(const vector<unsigned int>& cluster: clusterSz[SFC->numVNF]){ //
        if(cluster[0] > fullParVNFBlocks[0].size()) // if in first block(after src blk) 2 function is there, but cluster saying 3 needs to be parallel then continue next cluster.
            continue;

        unsigned int cur_level=0; ///< current level at which we have to insert all the nodes
        unordered_map<unsigned int,vector<unsigned int>> levelInfo;///< this stores level wise info {level i -> {0 -> blkId, 1->n, 2-> k}} to find nCk for block blkId of parSFC_Full


        if(showInConsole and showInConsoleDetailed){
            cout<<"\ncluster["; for(const auto& x: cluster) cout<<x<<" "; cout<<"]";
        }
        bool allBlksOfSFCDone = true;
        // iterate through the blocks except src (1) and dst(nBlk-1) and map it to cur cluster.
        for(unsigned int blk_id=0; blk_id<nBlk; blk_id++){
            const unsigned int& curBlk_size = fullParVNFBlocks[blk_id].size();  ///< current block size, that is num of VNFs present in it.

            /*!
             * It checks whether cluster_i is a feasible vector size and we can find same number of parallel VNFs specified by the cluster. cluster_i[l] number of func can run in parallel. \n
             * If we cannot find the same number of parallel VNFs specified by cluster_i, then it is not feasible. e.g. [2,2] is not feasible for {f1,f2,f3} block. \n
             * feasible [1, 2,1,1] and {{f1},{f2,f3,f4,f5}} where [1] is mapped to {f1} and  entire [2+1+1] is mapped to {f2,f3,f4,f5}
             */
            bool foundMapping=false; unsigned int delta=0; //< delta is range of level [endLevel-curLevel] upto which we can parallelize current block.
            for(unsigned int li=cur_level, sum_s=0; li<cluster.size() and sum_s < curBlk_size; li++){
                sum_s += cluster[li]; delta++;
                if(sum_s == curBlk_size){
                    foundMapping = true; break;
                }
            }
            if(!foundMapping) {
                if(showInConsole and showInConsoleDetailed){ cout<<"\tNot feasible for block{"; for(const auto& x: fullParVNFBlocks[blk_id]) cout<<"f"<<x<<","; cout<<"}";}
                allBlksOfSFCDone = false; // break lag gya isliye dfs call mt krna
                break;
            }

            for(unsigned int li=cur_level; li<cur_level+delta; li++){
                if(showInConsole and showInConsoleDetailed){
                    cout<<"\n\tL["<<li+1<<"]: \t";
                    for(const auto& allComb: nCk[curBlk_size][cluster[li]]) {
                        cout<<"{"; for(auto node: allComb) cout<<"f"<<fullParVNFBlocks[blk_id][node-1]<<",";  cout<<"}";
                    }
                }
                levelInfo[li] = {blk_id, curBlk_size, cluster[li]};
            }
            cur_level = cur_level+delta;
        }
        if(allBlksOfSFCDone) { //            cout<<"dfs called.";
            vector<vector<unsigned int>>partSFC; unsigned int mask=0;
            findAllPartSFC_Backtrack(0, partSFC, levelInfo, mask);
        }
    }

    if(showInConsole){
        cout<<"\nTotal PartSFC:"<<allPartParSFC.size();
        for(int idx=0; idx<allPartParSFC.size(); idx++){
            const auto& PCs = allPartParSFC[idx];
            cout<<"\nPC["<<idx+1<<"] ( "; unordered_map<unsigned int,unsigned int> freq;
            for(const auto& blks: PCs){
                cout<<"["; for(auto fn_id: blks){
                    cout<<"f"<<fn_id<<" ";
                    if(++freq[fn_id]>1)  throw runtime_error("Error in calculation of allPartSFC. Some fn_id repeated");
                } cout<<"]";
            } cout<<")";
        }
    }

}


/*! It reads data from sequential vector and then convert into full parallel service chain by detecting whether two function can be parallelised or not. \n
 * Also convert into parallel Adj list. \n
 * In the end write the parallel sfc into file.
 * @param testDirName to save the parallel conversion to file.
 * @param SFC ServiceFunctionChain object to convert sequential into parallel.
 * @param VNFNetwork object of VirtualNetworkFunctions class required to check two vnf are parallelizable or not.
 */
//template<typename type_res=unsigned int>
//void convertSeqSFC_to_FullParallelSFCAndWriteToFile(const string& testDirName, ServiceFunctionChain* SFC, VirtualNetworkFunctions<type_res> *VNFNetwork){
//    unsigned int sz = SFC->vnfSeq.size(); // total vnfs including src and dest
////    SFC->vnfBlocksPar.push_back({SFCsrc}); // stage 0, pushing src node
//    for(int cid=1; cid<sz-1; cid++){ // from SFCsrc+1 stg to SFCdst-1 stage
//        unsigned int prv_vnf = SFC->vnfSeq[cid-1], cur_vnf = SFC->vnfSeq[cid];  // Checking prv_vnf --> cur_vnf pairs
//        // NOT PARALLEL, if prv_vnf does not exist as first vnf in pair or if prv_vnf exist it is not parallel to cur_vnf, then it is not parallel pair
//        if(VNFNetwork->parallelPairs.count(prv_vnf)==0 or VNFNetwork->parallelPairs[prv_vnf].find(cur_vnf) == VNFNetwork->parallelPairs[prv_vnf].end()){
//            SFC->vnfBlocksPar.push_back({cur_vnf});// push cur_vnf as separte new stage
//        }else if(SFC->vnfBlocksPar.back().size() == 1) { //PARALLEL Pairs STG Size=1 and size of previous stg is just one, then we can directly push into that stg.
//            SFC->vnfBlocksPar.back().push_back(cur_vnf);
//        }else{ // PARALLEL Pairs and STG size > 1, from previous stg we have to check if cur_vnf is parallel to all prv_vnf in previous stage
//            bool pushInLstStg = true;
//            for(const unsigned int& lst_stg_vnf: SFC->vnfBlocksPar.back()){
//                if(VNFNetwork->parallelPairs.count(lst_stg_vnf)==0 or VNFNetwork->parallelPairs[lst_stg_vnf].find(cur_vnf) == VNFNetwork->parallelPairs[lst_stg_vnf].end()){
//                    pushInLstStg = false;   break;
//                }
//            }
//            if(pushInLstStg) SFC->vnfBlocksPar.back().push_back(cur_vnf);
//            else SFC->vnfBlocksPar.push_back({cur_vnf});
//        }//lst stg size>1
//    }// for cid
//    if(debug and SFC->index == 3)cout<<"\n\t[SFCs converted to Full Parallel VNFs Blocks]";
//
//    // Inserting into Adj List.
//    size_t stages = SFC->vnfBlocksPar.size(); ///< stages of SFC.
//    /// for each stage. stages-1 is the last stage
//    for(size_t s=0; s<=stages-2; s++ ){
//        ///for each vnf in source stage
//        for(int srcVNFid : SFC->vnfBlocksPar[s]){
//            /// for each vnf in next stage
//            for(int dstVNFid : SFC->vnfBlocksPar[s+1]){
//                SFC->pAdj[srcVNFid].push_back(dstVNFid);
//            }
//        }
//
//    }
//
//    // Writing to File.
//    ofstream fout;
//    string filepathExt = output_directory+testDirName+filename_sfc_parallel;///< path to .gv file without extention
//    fout.open(filepathExt.c_str(), ios::app);
//    if (!fout) {
//        string errorMsg = "File "+filepathExt+ " failed to open. Function: ";
//        fout.clear();
//        throw runtime_error(errorMsg+ __FUNCTION__);
//    }
//
//    fout << "\nFull Parallelised SFC:["<<SFC->name<<"],nVNF["<< SFC->numVNF<<"]::\t";
//    for(size_t i=0; i<SFC->vnfBlocksPar.size(); i++){
//        if(i==0 and SFC->vnfBlocksPar[i][0] == SFCsrc) fout << "(SRC -> ";
//        else if(i==SFC->vnfBlocksPar.size()-1 and SFC->vnfBlocksPar[i][0] == SFCdst)  fout << " DST)";
//        else{
//            fout<<"[ ";
//            for(int vnfid: SFC->vnfBlocksPar[i])
//                fout<<"f"<<vnfid<<char(96+SFC->I_VNFType2Inst[vnfid])<<"; ";
//            fout<<"] -> ";
//        }
//    }
//    fout.close();
//}

template<typename type_wgt=unsigned int, typename type_res=unsigned int>
void layerGraphConstruction_and_InstanceSelectionAndRouting1stVer(ServiceFunctionChain *cSFC, vector<ServiceFunctionChain*> allSFC,
                                                                  const VirtualNetworkFunctions<type_res> *VNFNetwork, const VirtualMachines<type_res> *VirtualNetwork,
                                                                  const PhysicalGraph<type_wgt, type_res> *PhysicalNetwork, bool showInConsole = false, bool showInConsoleDetailed = false) {

    /*! Lambda function to find all instances combination of parVNF in that stage. find_stg2IC_ofGivenBlk -> find stage to instnace combination of given block of sfc.
     * @param csfi current stage function index.
     * @param curInstComb current combination in iteration
     * @param stgid stgId/blockId for which we are finding combination of functions in that stg/block and to store in stg2InstCombinations.
     * @param curStg using to iterate all functions in the stage.
     * @param stg2InstCombinations It stores all the stage wise instances combination of all stage in partParSFC. {stgid -> 2d{ 1d instances combinations{pair<fun, inst>}  }}
     * For example:  partParSFC = { {1}, {6,4}, {5} }  \n
     * stg 0 (1 function has 3 instances),     B[0] = 2d{  1d[ pair<1a> ] [<1b>] [<1c>]  } \n
     * stg 1 (2 par function 2 & 3 instances), B[1] = 2d{ 1d[<6a> <4a>], [<6a> <4b>], [6a 4c], [6b 4a], [6b 4b], [6b 4c] } \n
     * stg 2 (1 function 2 instances),         B[2] = 2d{ 1d[5a] [5b] [5c] } \n
     * Time to calculte stg2InstCombinations -> if in any block number of parallel functions are 10 and each have 5 max instances\n
        inst = 2 (exe time: 1-2ms) (possibilites: 1024 (2^10)) \n
        inst = 3 (exe time: 38-40ms) (possibilites: 59 049 (3^10))\n
        inst = 4 (exe time: 580-600ms) (possibilites: 10 48 576 )\n
        inst = 5 (exe time: 5700-5800ms) (possibilites: 97 65 625)\
     */
    std::function<void(unsigned int, vector<pair<unsigned int,unsigned int>>&, unsigned int&, const vector<unsigned int>&, unordered_map<unsigned int, vector<vector<pair<unsigned int,unsigned int>>>>&)>
            find_stg2IC_ofGivenBlk = [&find_stg2IC_ofGivenBlk,&cSFC,&VNFNetwork] (unsigned int csfi, vector<pair<unsigned int,unsigned int>>& curInstComb,   unsigned int& stgid,
                                                                                  const vector<unsigned int>& curStg, unordered_map<unsigned int,  vector<vector<pair<unsigned int,unsigned int>>>> &stg2InstCombinations)->void{
        if(csfi == curStg.size()){ // all functions in stage iterated. curStg.size()==numOfFunction in that stage.
            stg2InstCombinations[stgid].push_back(curInstComb); // push the one answer into combination stg.
            return;
        }
        const unsigned int fnType = curStg[csfi];
        unsigned int totInstancs = VNFNetwork->VNFNodes.at(fnType)->numInstances;
        for(unsigned int fnInstId=1; fnInstId<=totInstancs; fnInstId++){
            if (VNFNetwork->utilization.count(fnType) and VNFNetwork->utilization.at(fnType).count(fnInstId) and ///< old utilization till now of VNF
                (VNFNetwork->utilization.at(fnType).at(fnInstId) + cSFC->trafficArrivalRate >  VNFNetwork->VNFNodes.at(fnType)->serviceRate))  {
                continue; // don't take this instance if its utilisation become more than service rate of function.
            }
            curInstComb.emplace_back(fnType, fnInstId); // push current instance
            find_stg2IC_ofGivenBlk(csfi+1, curInstComb, stgid, curStg, stg2InstCombinations); // call function for next instance
            curInstComb.pop_back(); // pop curInstComb instance and push next instance of same function.
        }

    };

    /*! For a given stg2InstCombinations, it enumerate all the possible mappings we can give in each stage and calculate time on the go.
     * @param stgid stgId/blockId for which we are enumerating instances.
     * @param curMapping cur function->instance mapping we iterating out of all possibilites.
     * @param bstMapping to save best mapping overall among all partial parallel chain/and its all instances.
     * @param minBstTime min time among all partial parallel chain/and its all instances.
     * @param partParSFC given partial SFC
     * @param stg2InstCombinations It contains all the stage wise instances combination of all stage in partParSFC. {stgid -> 2d{ 1d instances combinations{pair<fun, inst>}  }}
     * For example:  partParSFC = { {1}, {6,4}, {5} }  \n
     * stg 0 (1 function has 3 instances),     B[0] = 2d{  1d[ pair<1a> ] [<1b>] [<1c>]  } \n
     * stg 1 (2 par function 2 & 3 instances), B[1] = 2d{ 1d[<6a> <4a>], [<6a> <4b>], [6a 4c], [6b 4a], [6b 4b], [6b 4c] } \n
     * stg 2 (1 function 2 instances),         B[2] = 2d{ 1d[5a] [5b] [5c] }
     * allMappings are (total 36 = 3*6*2) \n
        0[1a 6a 4a 5a ]         1[1a 6a 4a 5b ]         2[1a 6a 4b 5a ]     3[1a 6a 4b 5b ]         4[1a 6a 4c 5a ]         5[1a 6a 4c 5b ]
        6[1a 6b 4a 5a ]         7[1a 6b 4a 5b ]         8[1a 6b 4b 5a ]     9[1a 6b 4b 5b ]         10[1a 6b 4c 5a ]        11[1a 6b 4c 5b ]
        12[1b 6a 4a 5a ]        13[1b 6a 4a 5b ]        14[1b 6a 4b 5a ]        15[1b 6a 4b 5b ]        16[1b 6a 4c 5a ]        17[1b 6a 4c 5b ]
        18[1b 6b 4a 5a ]        19[1b 6b 4a 5b ]        20[1b 6b 4b 5a ]        21[1b 6b 4b 5b ]        22[1b 6b 4c 5a ]        23[1b 6b 4c 5b ]
        24[1c 6a 4a 5a ]        25[1c 6a 4a 5b ]        26[1c 6a 4b 5a ]        27[1c 6a 4b 5b ]        28[1c 6a 4c 5a ]        29[1c 6a 4c 5b ]
        30[1c 6b 4a 5a ]        31[1c 6b 4a 5b ]        32[1c 6b 4b 5a ]
        3[1c 6b 4b 5b ]        34[1c 6b 4c 5a ]        35[1c 6b 4c 5b ] \n
     * 1 stage -> 10 parallel func each with 5 max instances -> 5^10 possibilities or 97,65,625 instances.
     */
    std::function<void(unsigned int , unordered_map<unsigned int,unsigned int>& , unordered_map<unsigned int,unsigned int>&, float& , const vector<vector<unsigned int>>&,  unordered_map<unsigned int, vector<vector<pair<unsigned int,unsigned int>>> >&)>
            instancesEnumeration_And_FindMinTime =[&instancesEnumeration_And_FindMinTime, &cSFC, &allSFC, &VNFNetwork, &VirtualNetwork, &PhysicalNetwork, &showInConsole, &showInConsoleDetailed]
            (unsigned int stgid, unordered_map<unsigned int,unsigned int>& curMapping, unordered_map<unsigned int,unsigned int>& curBstMapping,
             float& minBstTime, const vector<vector<unsigned int>>& partParSFC,  unordered_map<unsigned int, vector<vector<pair<unsigned int,unsigned int>>> >& stg2InstCombinations)->void{
        if(stgid == partParSFC.size()) { // found one mapping then find corresponding time
            float parallelCost=0, packetCost=0;
            parallelCost = calcObjectiveValuePar<type_wgt, type_res>(partParSFC,curMapping,  cSFC->index, allSFC, VNFNetwork, VirtualNetwork, PhysicalNetwork);
            // packet delay only in case of parallelism when number of blocks/stages < numOfVNFs (Sequential chain length) AND cost is less than min time among  partial sfc all instances.
            if( partParSFC.size() < cSFC->numVNF and parallelCost < minBstTime)
                packetCost = calcTime_PacketsDelay<type_res>(partParSFC, curMapping,  cSFC->index, VNFNetwork, VirtualNetwork);
            float curMapTime = parallelCost+packetCost; // float_max+flaot+max => inf

            if( curMapTime < minBstTime){ // current mapping ka time is less than min time among partial sfc all instances.
                minBstTime =  curMapTime;
                curBstMapping = curMapping;
            }
//                    else
//                        return;
            if(showInConsole and showInConsoleDetailed){
                cout<<"\n\t"<<"["; for(const auto &blk: partParSFC){ for(const auto& fnid: blk){ cout<<fnid<<char(96+curMapping.at(fnid))<<" ";  }  } cout<<"]";
                cout<<"["<<curMapTime<<"sec ("<<parallelCost<<"|"<<packetCost<<")]";
            }
            return;
        }
        for(const vector<pair<unsigned int,unsigned int>>& instComb: stg2InstCombinations[stgid]){
            bool instCanBePicked_UtilizationLess = true;
            for(const auto& [fnType, fnInstId]: instComb) {
                // is function is safe to pick ?
                if (VNFNetwork->utilization.count(fnType) and VNFNetwork->utilization.at(fnType).count(fnInstId) and ///< old utilization till now of VNF
                    (VNFNetwork->utilization.at(fnType).at(fnInstId) + cSFC->trafficArrivalRate >  VNFNetwork->VNFNodes.at(fnType)->serviceRate))  {
                    instCanBePicked_UtilizationLess = false; break;
                }
                curMapping[fnType] = fnInstId;
            }
            if(!instCanBePicked_UtilizationLess)continue;
            instancesEnumeration_And_FindMinTime(stgid+1,curMapping, curBstMapping, minBstTime, partParSFC, stg2InstCombinations);
        }
    };

    cSFC->bst_parlen_idx = cSFC->allPartParSFC.size(); // from partParSFC what is the best partial mapping.
    cSFC->bst_seqlen_time = std::numeric_limits<float>::max();
    cSFC->bst_parlen_time = std::numeric_limits<float>::max();
    float bst_partpar_time = std::numeric_limits<float>::max();
    //    vector<vector<unsigned int>> partParSFC = {{1},{6,4},{5}} ;
    for(int ppsidx=int( cSFC->allPartParSFC.size())-1; ppsidx>=0; --ppsidx){
        /*! {{1},{6,4},{5}}; Each Partial SFC is without src and dest block/stage. */
        const vector<vector<unsigned int>>& partParSFC=cSFC->allPartParSFC.at(ppsidx); ///< for each of the partial parallel SFC of the givenParVNF Blocks
        const unsigned int szStages = partParSFC.size(); ///< number of block/stage/level of the partParSFC without src and dst block/stage.

        /*! level to Instances Combinations = set of instance combination in block/stage/level index j. {stgid -> 2d{ 1d instances combinations{pair<fun, inst>}  }} */
        unordered_map<unsigned int, vector<vector<pair<unsigned int,unsigned int>>> > stg2InstCombinations;
        for(unsigned int stgid=0; stgid<szStages; stgid++){      // finding instances possibilities of each stage.
            const auto& curStg = partParSFC[stgid];
            vector<pair<unsigned int,unsigned int>> curInstComb;
            find_stg2IC_ofGivenBlk(0, curInstComb, stgid, curStg, stg2InstCombinations);
        }//stgid<szStages finding instances possibilities of each stage.
        // show stages wise instances combination

        if(showInConsole and showInConsoleDetailed){ // showing partParSFC info
            cout<<"\n partParSFC["<<ppsidx<<"]: "; for(const auto& blks: partParSFC){ cout<<"["; for(auto fn_id: blks){  cout<<"f"<<fn_id<<" ";  } cout<<"]"; } cout<<") ---------- - --------- - ------";
            for(int cur_lvl=0; cur_lvl<szStages; cur_lvl++){  // showing stage wise combination
                cout<<"\n\tSTG["<<cur_lvl<<"]("<<stg2InstCombinations[cur_lvl].size()<<") { ";
                for(const auto& instComb: stg2InstCombinations[cur_lvl]){
                    cout<<"[";  for(const auto& givenPair: instComb){  cout<<""<<givenPair.first<<char(givenPair.second-1+'a')<<" "; } cout<<"]";
                }  cout<<" }";
            }

        }

        /*! finding all the mapping possibilites for the current partParSFC instance combination at each stage.*/
        unordered_map<unsigned int,unsigned int> curMapping; ///< iterating mapping variable
        if(ppsidx == 0){// index 0 partial chain is same as given sfc, so finding best instance combinaton for given sequential sfc.
            instancesEnumeration_And_FindMinTime(0, curMapping,  cSFC->bst_seqlen_mapping, cSFC->bst_seqlen_time, partParSFC ,stg2InstCombinations);
            if(cSFC->bst_seqlen_time < cSFC->bst_parlen_time){ // if sequential is better than parallel than choose sequential.
                cSFC->bst_parlen_time = cSFC->bst_seqlen_time;
                cSFC->bst_parlen_idx = ppsidx;
                cSFC->bst_parlen_mapping = cSFC->bst_seqlen_mapping;
            }
        }
        else{
            instancesEnumeration_And_FindMinTime(0, curMapping,  cSFC->bst_parlen_mapping, bst_partpar_time, partParSFC, stg2InstCombinations);
            if(bst_partpar_time < cSFC->bst_parlen_time){
                cSFC->bst_parlen_idx = ppsidx;
                cSFC->bst_parlen_time = bst_partpar_time;
            }
//            unordered_map<unsigned int,unsigned int> curBstMapping; ///< in a single partPar SFC what is the best mapping which gives minimum time
//            float minCurTime = std::numeric_limits<float>::max(); ///< in a single partPar SFC what is the best minimum time
//            instancesEnumeration_And_FindMinTime(0, curMapping,  curBstMapping, minCurTime, partParSFC, stg2InstCombinations);
//            if(minCurTime < cSFC->bst_parlen_time){
//                cSFC->bst_parlen_idx = ppsidx;
//                cSFC->bst_parlen_time = minCurTime;
//                cSFC->bst_parlen_mapping = curBstMapping;
////                bst_stg2InstCombinations = stg2InstCombinations;
//            }
        }

    }// for each PartParSFC.


    if(cSFC->bst_parlen_idx == cSFC->allPartParSFC.size() ){
        string errorMsg = "Algorithm failed to find best partial parallel mapping for SFC["+to_string(cSFC->index)+ "]. Function: ";
        throw runtime_error(errorMsg+ __FUNCTION__);
    }

    if(cSFC->bst_seqlen_time == std::numeric_limits<float>::max()){
        string errorMsg = "Algorithm failed to find best sequential mapping for SFC["+to_string(cSFC->index)+ "]  Function: ";
        throw runtime_error(errorMsg+ __FUNCTION__);
    }

    if(showInConsole){
        cout<<"\n\n Objective Function Answer For SFC["<<cSFC->index<<"]";
        cout<<"\n\t Sequential: partIdx[0]  time:["<<cSFC->bst_seqlen_time<<"] :(";
        for(const auto &blk: cSFC->allPartParSFC[0]) {
            cout<<"[";  for(const auto& fnid: blk){
                cout<<fnid<<char(96+cSFC->bst_seqlen_mapping.at(fnid))<<" ";
            }   cout<<"]";
        }
        cout<<"\n\t Parallel: partIdx["<<cSFC->bst_parlen_idx<<"]  time:["<<cSFC->bst_parlen_time<<"] :(";
        for(const auto &blk: cSFC->allPartParSFC[cSFC->bst_parlen_idx]) {
            cout<<"[";  for(const auto& fnid: blk){
                cout<<fnid<<char(96+cSFC->bst_parlen_mapping.at(fnid))<<" ";
            }   cout<<"]";
        }

    }

}


#endif //SFC_PARALLELIZATION_ALGORITHMS_H
